diff --git a./build.sh b./build.sh
index b1900ae..1bb1a88 100755
--- a./build.sh
+++ b./build.sh
@@ -18,6 +18,7 @@ prepare(){
 
 
 build() {
+#	make world V=99 --debug=b 2>&1 | tee ${BUILDLOG_FILE}
 	make world V=99 2>&1 | tee ${BUILDLOG_FILE}
 }
 
@@ -33,7 +34,7 @@ fi
 
 
 while true; do
-	local ret
+#	local ret
 	case $1 in 
 		prepare)
 			prepare
diff --git a./configs/openwode-config b./configs/openwode-config
index 95803f2..e8ff6a7 100644
--- a./configs/openwode-config
+++ b./configs/openwode-config
@@ -305,7 +305,8 @@ CONFIG_INSTALL_LIBSTDCPP=y
 # CONFIG_USE_EGLIBC is not set
 # CONFIG_USE_GLIBC is not set
 CONFIG_USE_UCLIBC=y
-CONFIG_UCLIBC_VERSION_0_9_30_1=y
+CONFIG_UCLIBC_VERSION_0_9_29=y
+# CONFIG_UCLIBC_VERSION_0_9_30_1 is not set
 # CONFIG_UCLIBC_VERSION_0_9_30_2 is not set
 # CONFIG_UCLIBC_VERSION_0_9_30_3 is not set
 # CONFIG_UCLIBC_VERSION_NPTL is not set
@@ -319,9 +320,9 @@ CONFIG_GDB=y
 CONFIG_GCC_VERSION="4.3.3+cs"
 CONFIG_GCC_VERSION_4=y
 CONFIG_GCC_VERSION_4_3=y
-CONFIG_UCLIBC_VERSION="0.9.30.1"
+CONFIG_UCLIBC_VERSION="0.9.29"
 CONFIG_LIBC="uClibc"
-CONFIG_LIBC_VERSION="0.9.30.1"
+CONFIG_LIBC_VERSION="0.9.29"
 CONFIG_TARGET_SUFFIX="uclibcgnueabi"
 # CONFIG_SDK is not set
 # CONFIG_MAKE_TOOLCHAIN is not set
diff --git a./feeds.conf b./feeds.conf
index 28d2164..c4a18b4 100644
--- a./feeds.conf
+++ b./feeds.conf
@@ -1,4 +1,5 @@
-src-svn packages svn://svn.openwrt.org/openwrt/packages@26282
+src-git packages https://git.openwrt.org/openwrt/svn-archive/packages.git@26282
+#src-svn packages svn://svn.openwrt.org/openwrt/packages@26282
 src-svn xwrt http://x-wrt.googlecode.com/svn/branches/backfire_10.03/package
 src-svn luci http://svn.luci.subsignal.org/luci/branches/luci-0.10/contrib/package
 #src-svn phone svn://svn.openwrt.org/openwrt/feeds/phone
diff --git a./include/depends.mk b./include/depends.mk
index 65e9b25..8acd349 100644
--- a./include/depends.mk
+++ b./include/depends.mk
@@ -13,7 +13,7 @@
 
 DEP_FINDPARAMS := -x "*/.svn*" -x ".*" -x "*:*" -x "*\!*" -x "* *" -x "*\\\#*" -x "*/.*_check"
 
-find_md5=find $(1) -type f $(patsubst -x,-and -not -path,$(DEP_FINDPARAMS) $(2)) | md5s
+find_md5=find $(1) -type f $(patsubst -x,-and -not -path,$(DEP_FINDPARAMS) $(2)) | $(TOPDIR)/include/shell.sh md5s
 
 define rdep
   .PRECIOUS: $(2)
diff --git a./include/kernel.mk b./include/kernel.mk
index 63df959..e218433 100644
--- a./include/kernel.mk
+++ b./include/kernel.mk
@@ -76,7 +76,7 @@ define ModuleAutoLoad
 				echo '# May be required for rootfs' ; \
 			} ; \
 			for mod in $$$$$$$$2; do \
-				getvar mod; \
+				$(TOPDIR)/include/shell.sh getvar mod; \
 			done \
 		) > $(2)/etc/modules.d/$$$$$$$$1-$(1); \
 		modules="$$$$$$$${modules:+$$$$$$$$modules }$$$$$$$$1-$(1)"; \
diff --git a./include/package-ipkg.mk b./include/package-ipkg.mk
index 85f5c7c..2889bc4 100644
--- a./include/package-ipkg.mk
+++ b./include/package-ipkg.mk
@@ -29,11 +29,12 @@ IPKG_STATE_DIR:=$(TARGET_DIR)/usr/lib/opkg
 
 define BuildIPKGVariable
   $(call shexport,Package/$(1)/$(2))
-  $(1)_COMMANDS += var2file "$(call shvar,Package/$(1)/$(2))" $(2);
+  $(1)_COMMANDS += $(TOPDIR)/include/shell.sh var2file "$(call shvar,Package/$(1)/$(2))" $(2);
 endef
 
 PARENL :=(
 PARENR :=)
+RES=0
 
 dep_split=$(subst :,$(space),$(1))
 dep_rem=$(subst !,,$(subst $(strip $(PARENL)),,$(subst $(strip $(PARENR)),,$(word 1,$(call dep_split,$(1))))))
@@ -106,8 +107,15 @@ ifeq ($(DUMP),)
 		echo "Maintainer: $(MAINTAINER)"; \
 		echo "Architecture: $(PKGARCH)"; \
 		echo "Installed-Size: 0"; \
-		echo -n "Description: "; getvar $(call shvar,Package/$(1)/description) | sed -e 's,^[[:space:]]*, ,g'; \
+		echo -n "Description: "; \
  	) >> $$(IDIR_$(1))/CONTROL/control
+	RES=$(cat $(TOPDIR)/package/$(1)/Makefile | grep description -A1 | tail -1)
+	if [ $(RES) != 0 ]; then \
+		RES=$(cat $(TOPDIR)/package/base-files/Makefile | grep $(1) -A3 | grep TITLE:= | head -1 | cut -c10-); \
+		echo "$(RES)" >> $$(IDIR_$(1))/CONTROL/control; \
+	else \
+		echo "$(RES)" >> $$(IDIR_$(1))/CONTROL/control; \
+	fi
 	chmod 644 $$(IDIR_$(1))/CONTROL/control
 	(cd $$(IDIR_$(1))/CONTROL; \
 		$($(1)_COMMANDS) \
diff --git a./include/shell.sh b./include/shell.sh
old mode 100644
new mode 100744
diff --git a./include/target.mk b./include/target.mk
index 87efe5a..e40c967 100644
--- a./include/target.mk
+++ b./include/target.mk
@@ -72,10 +72,10 @@ define Profile
 		echo "Target-Profile-Kconfig: yes"; \
 	fi; \
 	echo "Target-Profile-Config: "; \
-	getvar "$(call shvar,Profile/$(1)/Config)"; \
+	$(TOPDIR)/include/shell.sh getvar "$(call shvar,Profile/$(1)/Config)"; \
 	echo "@@"; \
 	echo "Target-Profile-Description:"; \
-	getvar "$(call shvar,Profile/$(1)/Description)"; \
+	$(TOPDIR)/include/shell.sh getvar "$(call shvar,Profile/$(1)/Description)"; \
 	echo "@@"; \
 	echo;
   ifeq ($(CONFIG_TARGET_$(call target_conf,$(BOARD)_$(if $(SUBTARGET),$(SUBTARGET)_)$(1))),y)
@@ -191,7 +191,7 @@ define BuildTargets/DumpCurrent
 	 echo 'Linux-Release: $(LINUX_RELEASE)'; \
 	 echo 'Linux-Kernel-Arch: $(LINUX_KARCH)'; \
 	 echo 'Target-Description:'; \
-	 getvar $(call shvar,Target/Description); \
+	 $(TOPDIR)/include/shell.sh getvar $(call shvar,Target/Description); \
 	 echo '@@'; \
 	 echo 'Default-Packages: $(DEFAULT_PACKAGES)'; \
 	 $(DUMPINFO)
diff --git a./include/unpack.mk b./include/unpack.mk
index 0151675..08e2b8a 100644
--- a./include/unpack.mk
+++ b./include/unpack.mk
@@ -7,7 +7,7 @@
 
 # unpacking files with +s may break on some platforms. this typically emits error code 2
 ifneq ($(HOST_OS),Linux)
-  HOST_TAR:=trapret 2 $(TAR)
+  HOST_TAR:=$(TOPDIR)/include/shell.sh trapret 2 $(TAR)
 else
   HOST_TAR:=$(TAR)
 endif
diff --git a./package/acx/files/lib/wifi/acx.sh b./package/acx/files/lib/wifi/acx.sh
old mode 100644
new mode 100744
diff --git a./package/admswconfig/files/admswswitch.sh b./package/admswconfig/files/admswswitch.sh
old mode 100644
new mode 100744
diff --git a./package/base-files/Makefile b./package/base-files/Makefile
index af14cb4..b9e066b 100644
--- a./package/base-files/Makefile
+++ b./package/base-files/Makefile
@@ -387,6 +387,9 @@ define Package/base-files/install
 	ln -sf /tmp/resolv.conf /tmp/fstab /tmp/TZ $(1)/etc/
 	$(call ImageConfigOptions,$(1))
 	$(call Package/base-files/install-target,$(1))
+	if ! [ -f $(1)/CONTROL/conffiles ]; then \
+		touch $(1)/CONTROL/conffiles; \
+	fi
 	for conffile in $(1)/etc/config/*; do \
 		if [ -f "$$$$conffile" ]; then \
 			grep "$$$${conffile##$(1)}" $(1)/CONTROL/conffiles || \
diff --git a./package/base-files/files/etc/diag.sh b./package/base-files/files/etc/diag.sh
old mode 100644
new mode 100744
diff --git a./package/base-files/files/lib/functions/boot.sh b./package/base-files/files/lib/functions/boot.sh
old mode 100644
new mode 100744
diff --git a./package/base-files/files/lib/upgrade/common.sh b./package/base-files/files/lib/upgrade/common.sh
old mode 100644
new mode 100744
diff --git a./package/block-extroot/files/extmount.sh b./package/block-extroot/files/extmount.sh
old mode 100644
new mode 100744
diff --git a./package/block-mount/files/block.sh b./package/block-mount/files/block.sh
old mode 100644
new mode 100744
diff --git a./package/block-mount/files/fsck.sh b./package/block-mount/files/fsck.sh
old mode 100644
new mode 100744
diff --git a./package/block-mount/files/mount.sh b./package/block-mount/files/mount.sh
old mode 100644
new mode 100744
diff --git a./package/broadcom-wl/files/lib/wifi/broadcom.sh b./package/broadcom-wl/files/lib/wifi/broadcom.sh
old mode 100644
new mode 100744
diff --git a./package/busybox/Makefile b./package/busybox/Makefile
index 2833542..9a5c4a7 100644
--- a./package/busybox/Makefile
+++ b./package/busybox/Makefile
@@ -20,7 +20,7 @@ PKG_MD5SUM:=6059ac9456de6fb18dc8ee4cd0ec9240
 include $(INCLUDE_DIR)/package.mk
 
 ifeq ($(DUMP),)
-  STAMP_CONFIGURED:=$(strip $(STAMP_CONFIGURED))_$(shell grep '^CONFIG_BUSYBOX_' $(TOPDIR)/.config | md5s)
+  STAMP_CONFIGURED:=$(strip $(STAMP_CONFIGURED))_$(shell grep '^CONFIG_BUSYBOX_' $(TOPDIR)/.config | $(TOPDIR)/include/shell.sh md5s)
 endif
 
 init-y :=
diff --git a./package/comgt/files/3g.sh b./package/comgt/files/3g.sh
old mode 100644
new mode 100744
diff --git a./package/e2fsprogs/files/e2fsck.sh b./package/e2fsprogs/files/e2fsck.sh
old mode 100644
new mode 100744
diff --git a./package/firewall/files/lib/config.sh b./package/firewall/files/lib/config.sh
old mode 100644
new mode 100744
diff --git a./package/firewall/files/lib/core.sh b./package/firewall/files/lib/core.sh
old mode 100644
new mode 100744
diff --git a./package/firewall/files/lib/core_forwarding.sh b./package/firewall/files/lib/core_forwarding.sh
old mode 100644
new mode 100744
diff --git a./package/firewall/files/lib/core_init.sh b./package/firewall/files/lib/core_init.sh
old mode 100644
new mode 100744
diff --git a./package/firewall/files/lib/core_interface.sh b./package/firewall/files/lib/core_interface.sh
old mode 100644
new mode 100744
diff --git a./package/firewall/files/lib/core_redirect.sh b./package/firewall/files/lib/core_redirect.sh
old mode 100644
new mode 100744
diff --git a./package/firewall/files/lib/core_rule.sh b./package/firewall/files/lib/core_rule.sh
old mode 100644
new mode 100744
diff --git a./package/firewall/files/lib/fw.sh b./package/firewall/files/lib/fw.sh
old mode 100644
new mode 100744
diff --git a./package/firewall/files/lib/uci_firewall.sh b./package/firewall/files/lib/uci_firewall.sh
old mode 100644
new mode 100744
diff --git a./package/hostapd/files/hostapd.sh b./package/hostapd/files/hostapd.sh
old mode 100644
new mode 100744
diff --git a./package/hostapd/files/wpa_supplicant.sh b./package/hostapd/files/wpa_supplicant.sh
old mode 100644
new mode 100744
diff --git a./package/hostapd/files/wps-hotplug.sh b./package/hostapd/files/wps-hotplug.sh
old mode 100644
new mode 100744
diff --git a./package/ifxmips-dsl-control/files/ifx_cpe_control_init.sh b./package/ifxmips-dsl-control/files/ifx_cpe_control_init.sh
old mode 100644
new mode 100744
diff --git a./package/iptables/Makefile b./package/iptables/Makefile
index c7264b0..76d2c87 100644
--- a./package/iptables/Makefile
+++ b./package/iptables/Makefile
@@ -25,7 +25,7 @@ include $(INCLUDE_DIR)/package.mk
 ifeq ($(DUMP),)
   -include $(LINUX_DIR)/.config
   include $(INCLUDE_DIR)/netfilter.mk
-  STAMP_CONFIGURED:=$(strip $(STAMP_CONFIGURED))_$(shell grep 'NETFILTER' $(LINUX_DIR)/.config | md5s)
+  STAMP_CONFIGURED:=$(strip $(STAMP_CONFIGURED))_$(shell grep 'NETFILTER' $(LINUX_DIR)/.config | $(TOPDIR)/include/shell.sh md5s)
 endif
 
 
diff --git a./package/libipfix/extra/append-wprobe-ie.pl b./package/libipfix/extra/append-wprobe-ie.pl
old mode 100644
new mode 100744
diff --git a./package/linux-atm/files/ipoa.sh b./package/linux-atm/files/ipoa.sh
old mode 100644
new mode 100744
diff --git a./package/mac80211/files/lib/wifi/mac80211.sh b./package/mac80211/files/lib/wifi/mac80211.sh
old mode 100644
new mode 100744
diff --git a./package/ppp/files/ppp.sh b./package/ppp/files/ppp.sh
old mode 100644
new mode 100744
diff --git a./package/ppp/files/pppoa.sh b./package/ppp/files/pppoa.sh
old mode 100644
new mode 100744
diff --git a./package/ppp/files/pppoe.sh b./package/ppp/files/pppoe.sh
old mode 100644
new mode 100744
diff --git a./package/pptp/files/pptp.sh b./package/pptp/files/pptp.sh
old mode 100644
new mode 100744
diff --git a./package/relayd/files/relay.sh b./package/relayd/files/relay.sh
old mode 100644
new mode 100744
diff --git a./package/swconfig/files/switch.sh b./package/swconfig/files/switch.sh
old mode 100644
new mode 100744
diff --git a./package/switch/files/switch.sh b./package/switch/files/switch.sh
old mode 100644
new mode 100744
diff --git a./package/uboot-lantiq/Makefile b./package/uboot-lantiq/Makefile
index d2a9cf2..6c5f349 100644
--- a./package/uboot-lantiq/Makefile
+++ b./package/uboot-lantiq/Makefile
@@ -21,7 +21,7 @@ PKG_TARGETS:=bin
 include $(INCLUDE_DIR)/package.mk
 
 ifeq ($(DUMP),)
-  STAMP_CONFIGURED:=$(strip $(STAMP_CONFIGURED))_$(shell grep '^CONFIG_UBOOT_' $(TOPDIR)/.config | md5s)
+  STAMP_CONFIGURED:=$(strip $(STAMP_CONFIGURED))_$(shell grep '^CONFIG_UBOOT_' $(TOPDIR)/.config | $(TOPDIR)/include/shell.sh md5s)
 endif
 
 define Package/uboot-lantiq
diff --git a./package/uci/files/lib/config/uci.sh b./package/uci/files/lib/config/uci.sh
old mode 100644
new mode 100744
diff --git a./rules.mk b./rules.mk
index 0068350..4d42bd9 100644
--- a./rules.mk
+++ b./rules.mk
@@ -16,7 +16,7 @@ include $(TOPDIR)/include/verbose.mk
 
 TMP_DIR:=$(TOPDIR)/tmp
 
-export SHELL=/usr/bin/env bash -c '. $(TOPDIR)/include/shell.sh; eval "$$2"' --
+export SHELL=/usr/bin/env bash -c '. $(TOPDIR)/include/shell.sh | eval "$$2"' --
 
 qstrip=$(strip $(subst ",,$(1)))
 #"))
diff --git a./scripts/combined-image.sh b./scripts/combined-image.sh
old mode 100644
new mode 100744
diff --git a./scripts/config/lxdialog/check-lxdialog.sh b./scripts/config/lxdialog/check-lxdialog.sh
old mode 100644
new mode 100744
diff --git a./scripts/flashing/adam2flash-502T.pl b./scripts/flashing/adam2flash-502T.pl
old mode 100644
new mode 100744
diff --git a./scripts/flashing/adam2flash-fritzbox.pl b./scripts/flashing/adam2flash-fritzbox.pl
old mode 100644
new mode 100744
diff --git a./scripts/flashing/adsl2mue_flash.pl b./scripts/flashing/adsl2mue_flash.pl
old mode 100644
new mode 100744
diff --git a./target/linux/adm5120/base-files/lib/upgrade/platform.sh b./target/linux/adm5120/base-files/lib/upgrade/platform.sh
old mode 100644
new mode 100744
diff --git a./target/linux/ar7/base-files/etc/diag.sh b./target/linux/ar7/base-files/etc/diag.sh
old mode 100644
new mode 100744
diff --git a./target/linux/atheros/base-files/lib/upgrade/platform.sh b./target/linux/atheros/base-files/lib/upgrade/platform.sh
old mode 100644
new mode 100744
diff --git a./target/linux/au1000/base-files/etc/diag.sh b./target/linux/au1000/base-files/etc/diag.sh
old mode 100644
new mode 100744
diff --git a./target/linux/brcm-2.4/base-files/etc/diag.sh b./target/linux/brcm-2.4/base-files/etc/diag.sh
old mode 100644
new mode 100744
diff --git a./target/linux/brcm-2.4/base-files/lib/upgrade/platform.sh b./target/linux/brcm-2.4/base-files/lib/upgrade/platform.sh
old mode 100644
new mode 100744
diff --git a./target/linux/brcm63xx/base-files/lib/upgrade/platform.sh b./target/linux/brcm63xx/base-files/lib/upgrade/platform.sh
old mode 100644
new mode 100744
diff --git a./target/linux/cobalt/base-files/etc/diag.sh b./target/linux/cobalt/base-files/etc/diag.sh
old mode 100644
new mode 100744
diff --git a./target/linux/lpc313x/base-files/lib/wode/cifs_functions.sh b./target/linux/lpc313x/base-files/lib/wode/cifs_functions.sh
old mode 100644
new mode 100744
diff --git a./target/linux/lpc313x/base-files/lib/wode/mmc_functions.sh b./target/linux/lpc313x/base-files/lib/wode/mmc_functions.sh
old mode 100644
new mode 100744
diff --git a./target/linux/lpc313x/base-files/lib/wode/network_functions.sh b./target/linux/lpc313x/base-files/lib/wode/network_functions.sh
old mode 100644
new mode 100744
diff --git a./target/linux/lpc313x/base-files/lib/wode/wifi_functions.sh b./target/linux/lpc313x/base-files/lib/wode/wifi_functions.sh
old mode 100644
new mode 100744
diff --git a./target/linux/lpc313x/config-2.6.32 b./target/linux/lpc313x/config-2.6.32
index 855ac12..a057c8a 100644
--- a./target/linux/lpc313x/config-2.6.32
+++ b./target/linux/lpc313x/config-2.6.32
@@ -60,7 +61,8 @@ CONFIG_DEBUG_INFO=y
 CONFIG_DEBUG_KERNEL=y
 CONFIG_DEBUG_PREEMPT=y
 # CONFIG_DEBUG_USER is not set
-CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_GZIP=y
+# CONFIG_DECOMPRESS_LZMA is not set
 CONFIG_DEFAULT_TCP_CONG="cubic"
 CONFIG_DETECT_SOFTLOCKUP=y
 # CONFIG_DM9000 is not set
@@ -124,6 +126,8 @@ CONFIG_INPUT=y
 # CONFIG_ISDN is not set
 CONFIG_ISO9660_FS=y
 CONFIG_JBD=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
 CONFIG_KEXEC=y
 # CONFIG_LDM_DEBUG is not set
 CONFIG_LDM_PARTITION=y
diff --git a./target/linux/lpc313x/files/arch/arm/mach-lpc313x/dma.c b./target/linux/lpc313x/files/arch/arm/mach-lpc313x/dma.c
index ef04e3b..91344ff 100644
--- a./target/linux/lpc313x/files/arch/arm/mach-lpc313x/dma.c
+++ b./target/linux/lpc313x/files/arch/arm/mach-lpc313x/dma.c
@@ -32,12 +32,8 @@
 #include <asm/uaccess.h>
 #include <asm/irq.h>
 #include <asm/dma.h>
-
-
-#include <mach/hardware.h>
-#include <mach/registers.h>
-#include <mach/dma.h>
 #include <mach/cgu.h>
+#include <mach/dma.h>
 
 
 static spinlock_t driver_lock = SPIN_LOCK_UNLOCKED; /* to guard state variables */
@@ -59,7 +55,9 @@ static struct dma_channel {
 } dma_channels[DMA_MAX_CHANNELS];
 
 static unsigned int     dma_irq_mask = 0xFFFFFFFF;
-static int sg_higher_channel = 0;
+static int sg_higher_channel[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+static int softirqmask[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+static int softirqen = 0;
 
 static int dma_channels_requested = 0;
 
@@ -96,7 +94,7 @@ int dma_prog_channel (unsigned int chn, dma_setup_t *dma_setup)
 	if ((chn >= DMA_MAX_CHANNELS) || !dma_channels[chn].name ||
 		dma_valid_config(dma_setup) )
 		return -EINVAL;
-	
+
 	DMACH_SRC_ADDR(chn) = dma_setup->src_address;
 	DMACH_DST_ADDR(chn) = dma_setup->dest_address;
 	DMACH_LEN(chn) = dma_setup->trans_length;
@@ -119,9 +117,9 @@ int dma_request_channel (char *name, dma_cb_t cb, void *data)
 
 	memset(&dma_setup, 0, sizeof(dma_setup));
 
-	for (chn = 0, mask = 1; chn < DMA_MAX_CHANNELS; chn++) 
+	for (chn = 0, mask = 1; chn < DMA_MAX_CHANNELS; chn++)
 	{
-		if (!dma_channels[chn].name) 
+		if (!dma_channels[chn].name)
 		{
 			dma_increment_usage();
 			dma_channels[chn].name = name;
@@ -152,7 +150,7 @@ int dma_request_specific_channel (int chn, char *name, void (*cb)(int, dma_irq_t
 	if (chn >= DMA_MAX_CHANNELS || !name)
 		return -EINVAL;
 
-	if (dma_channels[chn].name) 
+	if (dma_channels[chn].name)
 		return -EBUSY;
 
 	lpc313x_dma_lock();
@@ -224,6 +222,17 @@ int dma_stop_channel (unsigned int chn)
 	return 0;
 }
 
+int dma_stop_channel_sg (unsigned int chn)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	/* Disable the companion channel only */
+	DMACH_EN(chn - 1) = 0;
+	return 0;
+}
+
 int dma_release_channel (unsigned int chn)
 {
 	unsigned int mask = (0x3 << (chn * 2));
@@ -234,7 +243,7 @@ int dma_release_channel (unsigned int chn)
 	}
 
 	lpc313x_dma_lock();
-	
+
 	local_irq_save(flags);
 
 	/* Otherwise an unexpected interrupt can occur when the channel is reallocated for another purpose */
@@ -251,7 +260,7 @@ int dma_release_channel (unsigned int chn)
 
 	lpc313x_dma_unlock();
 	dma_decrement_usage();
-	
+
 	return 0;
 }
 
@@ -268,24 +277,28 @@ static irqreturn_t dma_irq_handler (int irq, void *dev_id)
 		if (dma_irq_status & mask) {
 			DMACH_IRQ_STATUS = mask;
 			if (dma_channels[chn].callback_handler)
-				(dma_channels[chn].callback_handler) 
+				(dma_channels[chn].callback_handler)
 					(chn, DMA_IRQ_FINISHED, dma_channels[chn].data);
 		}
 		mask = mask << 1;
 		if (dma_irq_status & mask) {
 			DMACH_IRQ_STATUS = mask;
 			if (dma_channels[chn].callback_handler)
-				(dma_channels[chn].callback_handler) 
+				(dma_channels[chn].callback_handler)
 					(chn, DMA_IRQ_HALFWAY, dma_channels[chn].data);
 		}
 		mask = mask << 1;
 	}
 
-	if (dma_irq_status & DMA_IRQS_SOFT) { /* Soft int */ 
+	if (dma_irq_status & DMA_IRQS_SOFT) { /* Soft int */
 		DMACH_IRQ_STATUS = DMA_IRQS_SOFT;
-		if (sg_higher_channel && dma_channels[sg_higher_channel].callback_handler)
-			(dma_channels[sg_higher_channel].callback_handler)
-				(sg_higher_channel, DMA_IRQ_SOFTINT, dma_channels[sg_higher_channel].data);
+		for (chn = 0; chn < DMA_MAX_CHANNELS; chn++) {
+			if (sg_higher_channel[chn] && softirqmask[chn] &&
+				dma_channels[sg_higher_channel[chn]].callback_handler)
+			(dma_channels[sg_higher_channel[chn]].callback_handler)
+				(sg_higher_channel[chn], DMA_IRQ_SOFTINT,
+				dma_channels[sg_higher_channel[chn]].data);
+		}
 	}
 
 	if (dma_irq_status & DMA_IRQS_ABORT) { /* DMA abort */
@@ -293,7 +306,7 @@ static irqreturn_t dma_irq_handler (int irq, void *dev_id)
 		DMACH_IRQ_STATUS = DMA_IRQS_ABORT;
 		for (chn = 0; chn < DMA_MAX_CHANNELS; chn++)
 			if (dma_channels[chn].callback_handler)
-				(dma_channels[chn].callback_handler) 
+				(dma_channels[chn].callback_handler)
 					(chn, DMA_IRQ_DMAABORT, dma_channels[chn].data);
 	}
 
@@ -340,7 +353,8 @@ int dma_current_state (unsigned int   chn,
 	return 0;
 }
 
-int dma_request_sg_channel (char *name, dma_cb_t cb, void *data)
+int dma_request_sg_channel (char *name, dma_cb_t cb, void *data,
+		dma_cb_t cb1, void *data1, int usesoftirq)
 {
 	unsigned int chn;
 	unsigned long flags;
@@ -349,18 +363,18 @@ int dma_request_sg_channel (char *name, dma_cb_t cb, void *data)
 	if (!name)
 		return -EINVAL;
 
-	if (sg_higher_channel)
+	if (softirqen & usesoftirq)
 		return -EBUSY;
 
 	lpc313x_dma_lock();
 
-	for (chn = 0; chn < DMA_MAX_CHANNELS - 1; chn++) 
+	for (chn = 0; chn < DMA_MAX_CHANNELS - 1; chn++)
 		if (!dma_channels[chn].name && !dma_channels[chn + 1].name) {
-			sg_higher_channel = chn + 1;
+			sg_higher_channel[chn] = chn + 1;
 			break;
 		}
 
-	if (!sg_higher_channel) {
+	if (!sg_higher_channel[chn]) {
 		lpc313x_dma_unlock();
 		return -EBUSY;
 	}
@@ -368,25 +382,35 @@ int dma_request_sg_channel (char *name, dma_cb_t cb, void *data)
 	memset(&dma_setup, 0, sizeof(dma_setup));
 
 	dma_increment_usage();
-	dma_channels[sg_higher_channel].name = name;
-	dma_channels[sg_higher_channel - 1].name = name;
+	dma_channels[sg_higher_channel[chn]].name = name;
+	dma_channels[sg_higher_channel[chn] - 1].name = name;
 
 	if (cb) {
-		dma_channels[sg_higher_channel].callback_handler = cb;
-		dma_channels[sg_higher_channel].data = data;
+		dma_channels[sg_higher_channel[chn]].callback_handler = cb;
+		dma_channels[sg_higher_channel[chn]].data = data;
+	}
+	if(cb1) {
+		dma_channels[sg_higher_channel[chn] - 1].callback_handler = cb1;
+		dma_channels[sg_higher_channel[chn] - 1].data = data1;
+	}
+	dma_prog_channel (sg_higher_channel[chn], &dma_setup);
+
+	if (usesoftirq) {
+		local_irq_save(flags);
+		softirqen = 1;
+		softirqmask[chn] = 1;
+		dma_irq_mask &= ~DMA_IRQS_SOFT;  /* enable the soft IRQ */
+		DMACH_IRQ_MASK = dma_irq_mask;
+		local_irq_restore(flags);
 	}
-	dma_prog_channel (sg_higher_channel, &dma_setup);
 
-	local_irq_save(flags);
-	dma_irq_mask &= ~DMA_IRQS_SOFT;  /* enable the soft IRQ */
-	DMACH_IRQ_MASK = dma_irq_mask;
-	local_irq_restore(flags);
 	lpc313x_dma_unlock();
 
-	return sg_higher_channel;
+	return sg_higher_channel[chn];
 }
 
-int dma_request_specific_sg_channel (int chn, char *name, dma_cb_t cb, void *data)
+int dma_request_specific_sg_channel (int chn, char *name, dma_cb_t cb,
+		void *data, dma_cb_t cb1, void *data1, int usesoftirq)
 {
 	unsigned long flags;
 	dma_setup_t  dma_setup;
@@ -394,32 +418,42 @@ int dma_request_specific_sg_channel (int chn, char *name, dma_cb_t cb, void *dat
 	if (!name)
 		return -EINVAL;
 
-	if (sg_higher_channel || dma_channels[chn].name || dma_channels[chn - 1].name)
+	if (softirqen & usesoftirq)
+		return -EBUSY;
+
+	if (sg_higher_channel[chn] || dma_channels[chn].name || dma_channels[chn - 1].name)
 		return -EBUSY;
 
 	lpc313x_dma_lock();
-	
-	sg_higher_channel = chn;
+
+	sg_higher_channel[chn] = chn;
 
 	memset(&dma_setup, 0, sizeof(dma_setup));
 
 	dma_increment_usage();
-	dma_channels[sg_higher_channel].name = name;
-	dma_channels[sg_higher_channel - 1].name = name;
+	dma_channels[sg_higher_channel[chn]].name = name;
+	dma_channels[sg_higher_channel[chn] - 1].name = name;
 
 	if (cb) {
-		dma_channels[sg_higher_channel].callback_handler = cb;
-		dma_channels[sg_higher_channel].data = data;
+		dma_channels[sg_higher_channel[chn]].callback_handler = cb;
+		dma_channels[sg_higher_channel[chn]].data = data;
+	}
+	if(cb1) {
+		dma_channels[sg_higher_channel[chn] - 1].callback_handler = cb1;
+		dma_channels[sg_higher_channel[chn] - 1].data = data1;
+	}
+	dma_prog_channel (sg_higher_channel[chn], &dma_setup);
+
+	if (usesoftirq) {
+		local_irq_save(flags);
+		softirqen = 1;
+		softirqmask[chn] = 1;
+		dma_irq_mask &= ~DMA_IRQS_SOFT;  /* enable the soft IRQ */
+		DMACH_IRQ_MASK = dma_irq_mask;
+		local_irq_restore(flags);
 	}
-	dma_prog_channel (sg_higher_channel, &dma_setup);
-
-	local_irq_save(flags);
-	dma_irq_mask &= ~DMA_IRQS_SOFT;  /* enable the soft IRQ */
-	DMACH_IRQ_MASK = dma_irq_mask;
-	local_irq_restore(flags);
-	lpc313x_dma_unlock();
 
-	return sg_higher_channel;
+	return sg_higher_channel[chn];
 }
 
 int dma_prog_sg_channel(int chn, u32 dma_sg_list)
@@ -441,6 +475,14 @@ int dma_prog_sg_channel(int chn, u32 dma_sg_list)
 	return 0;
 }
 
+int dma_channel_enabled(unsigned int chn)
+{
+	if (chn >= DMA_MAX_CHANNELS || !dma_channels[chn].name) {
+		return -EINVAL;
+	}
+
+	return (DMACH_EN(chn) & 1);
+}
 
 static int __init lpc313x_dma_init (void)
 {
@@ -466,21 +508,26 @@ int dma_release_sg_channel (unsigned int chn)
 	}
 
 	lpc313x_dma_lock();
-	local_irq_save(flags);
-	dma_irq_mask |= DMA_IRQS_SOFT;
-	DMACH_IRQ_MASK = dma_irq_mask;
-	local_irq_restore(flags);
-	
+
+	if (softirqmask[chn] != 0) {
+		local_irq_save(flags);
+		softirqen = 0;
+		softirqmask[chn] = 0;
+		dma_irq_mask |= DMA_IRQS_SOFT;
+		DMACH_IRQ_MASK = dma_irq_mask;
+		local_irq_restore(flags);
+	}
+
 	dma_channels[chn].name = NULL;
 	dma_channels[chn].callback_handler = NULL;
 	dma_channels[chn].data = NULL;
-	
+
 	chn--;
 	dma_channels[chn].name = NULL;
 	dma_channels[chn].callback_handler = NULL;
 	dma_channels[chn].data = NULL;
-	
-	sg_higher_channel = 0;
+
+	sg_higher_channel[chn] = 0;
 
 	lpc313x_dma_unlock();
 	dma_decrement_usage();
@@ -510,4 +557,4 @@ EXPORT_SYMBOL(dma_request_specific_sg_channel);
 EXPORT_SYMBOL(dma_prog_sg_channel);
 EXPORT_SYMBOL(dma_release_sg_channel);
 EXPORT_SYMBOL(dma_prepare_sg_list);
-
+EXPORT_SYMBOL(dma_channel_enabled);
diff --git a./target/linux/lpc313x/files/arch/arm/mach-lpc313x/include/mach/cgu.h b./target/linux/lpc313x/files/arch/arm/mach-lpc313x/include/mach/cgu.h
index 7894965..30712ee 100644
--- a./target/linux/lpc313x/files/arch/arm/mach-lpc313x/include/mach/cgu.h
+++ b./target/linux/lpc313x/files/arch/arm/mach-lpc313x/include/mach/cgu.h
@@ -24,6 +24,8 @@
 #ifndef LPC313X_CGU_H
 #define LPC313X_CGU_H
 
+#include <mach/hardware.h>
+
  /***********************************************************************
  * CGU register definitions
  **********************************************************************/
@@ -124,6 +126,10 @@ typedef volatile struct
   CGU_HP_CFG_REGS hp[2];
 } CGU_CONFIG_REGS;
 
+/* macros to convert phys to virtual & virtual to phys memory location*/
+#define io_p2v(x) (0xf0000000 | (((x) & 0xff000000) >> 4) | ((x) & 0x000fffff))
+#define io_v2p(x) (             (((x) & 0x0ff00000) << 4) | ((x) & 0x000fffff))
+
 //#define CGU_SB    ((CGU_SB_REGS_T*) io_p2v(CGU_SB_PHYS))
 //#define CGU_CFG   ((CGU_CONFIG_REGS*) io_p2v(CGU_CFG_PHYS))
 #define CGU_SB  ((CGU_SB_REGS_T  *)(CGU_SB_VIRT))
diff --git a./target/linux/lpc313x/files/arch/arm/mach-lpc313x/include/mach/dma.h b./target/linux/lpc313x/files/arch/arm/mach-lpc313x/include/mach/dma.h
index d0c4f1a..080c4d1 100644
--- a./target/linux/lpc313x/files/arch/arm/mach-lpc313x/include/mach/dma.h
+++ b./target/linux/lpc313x/files/arch/arm/mach-lpc313x/include/mach/dma.h
@@ -1,5 +1,5 @@
 /*  linux/arch/arm/mach-lpc313x/include/mach/dma.h
- *  
+ *
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
@@ -24,6 +24,7 @@
 #ifndef __ASM_ARCH_DMA_H
 #define __ASM_ARCH_DMA_H
 
+#include <mach/hardware.h>
 
 /***********************************************************************
  * DMA register definitions
@@ -99,14 +100,14 @@
 /*
  * Type of interrupt
  */
-typedef enum 
+typedef enum
 {
 	DMA_IRQ_FINISHED = 0,
 	DMA_IRQ_HALFWAY,
 	DMA_IRQ_SOFTINT,
 	DMA_IRQ_DMAABORT
 } dma_irq_type_t;
- /* 
+ /*
  * DMA IRQ channel callback function
  * parameters:
  * 1st parameter - channel number for which an IRQ occured
@@ -148,7 +149,7 @@ typedef struct dma_setup
 } dma_setup_t;
 
 /*
- * SDMA scatter-gather list structure 
+ * SDMA scatter-gather list structure
  */
 typedef struct dma_sg_ll
 {
@@ -169,7 +170,7 @@ typedef struct dma_sg_ll
  * 1st parameter - channel number, obtained from dma_request_channel()
  * 2nd parameter - ptr to the structure containing setup info for the channel
  *
- * Returns: 0 on success, otherwise failure 
+ * Returns: 0 on success, otherwise failure
  */
 int dma_prog_channel (unsigned int, dma_setup_t   *);
 
@@ -183,7 +184,7 @@ int dma_prog_channel (unsigned int, dma_setup_t   *);
  * 3rd parameter - additional data (callback-specific context) to be passed
  *                 to the callback function when it's invoked
  *
- * Returns: channel number on success, otherwise (negative) failure 
+ * Returns: channel number on success, otherwise (negative) failure
  */
 int dma_request_channel (char *, dma_cb_t cb, void *);
 
@@ -199,7 +200,7 @@ int dma_request_channel (char *, dma_cb_t cb, void *);
  *                 to the callback function when it's invoked
  *
  *
- * Returns: channel number on success, otherwise (negative) failure 
+ * Returns: channel number on success, otherwise (negative) failure
  */
 int dma_request_specific_channel (int, char *, dma_cb_t cb, void *);
 
@@ -222,7 +223,7 @@ int dma_set_irq_mask(unsigned int, int, int);
  * Function parameters:
  * 1st parameter - SDMA channel number
  *
- * Returns: 0 on success, otherwise failure 
+ * Returns: 0 on success, otherwise failure
  */
 int dma_start_channel (unsigned int);
 
@@ -232,7 +233,7 @@ int dma_start_channel (unsigned int);
  * Function parameters:
  * 1st parameter - SDMA channel number
  *
- * Returns: 0 on success, otherwise failure 
+ * Returns: 0 on success, otherwise failure
  */
 int dma_stop_channel (unsigned int);
 
@@ -242,7 +243,7 @@ int dma_stop_channel (unsigned int);
  * Function parameters:
  * 1st parameter - SDMA channel number
  *
- * Returns: 0 on success, otherwise failure 
+ * Returns: 0 on success, otherwise failure
  */
 int dma_release_channel (unsigned int);
 
@@ -253,7 +254,7 @@ int dma_release_channel (unsigned int);
  * 1st parameter - SDMA channel number
  * 2nd parameter - ptr to the counter variable to be filled
  *
- * Returns: 0 on success, otherwise failure 
+ * Returns: 0 on success, otherwise failure
  */
 int dma_read_counter (unsigned int, unsigned int *);
 
@@ -264,7 +265,7 @@ int dma_read_counter (unsigned int, unsigned int *);
  * 1st parameter - SDMA channel number
  * 2nd parameter - value to be written
  *
- * Returns: 0 on success, otherwise failure 
+ * Returns: 0 on success, otherwise failure
  */
 int dma_write_counter (unsigned int, u32);
 
@@ -280,7 +281,7 @@ int dma_write_counter (unsigned int, u32);
  * 6th parameter - ptr to the enable flag variable to be filled
  * 7th parameter - ptr to the address counter variable to be filled
  *
- * Returns: 0 on success, otherwise failure 
+ * Returns: 0 on success, otherwise failure
  */
 int dma_current_state    (unsigned int, unsigned int *, unsigned int *, unsigned int *, unsigned int  *, unsigned int  *, unsigned int  *);
 
@@ -291,9 +292,15 @@ int dma_current_state    (unsigned int, unsigned int *, unsigned int *, unsigned
  * Function parameters:
  * 1st parameter - free-form string identifier of channel.
  * 2nd parameter - callback function to be invoked when an interrupt
- *                 occurs for this channel
+ *                 occurs for the first channel
  * 3rd parameter - additional data (callback-specific context) to be passed
- *                 to the callback function when it's invoked
+ *                 to the callback function of first channel when it's invoked
+ * 4th parameter - callback function to be invoked when an interrupt
+ *                 occurs for the second channel
+ * 5th parameter - additional data (callback-specific context) to be passed
+ *                 to the callback function of second channel when it's invoked
+ * 6th parameter - flag to enable soft IRQ for this channel. Only 1 channel
+ *                 may be enabled with soft-irq.
  *
  * Callback parameters:
  * 1st parameter - channel number for which an IRQ occured
@@ -303,7 +310,8 @@ int dma_current_state    (unsigned int, unsigned int *, unsigned int *, unsigned
  *
  * Returns: bigger channel number on success, otherwise negative error code
  */
-int dma_request_sg_channel (char *, dma_cb_t cb, void *);
+int dma_request_sg_channel (char *, dma_cb_t cb1, void *,
+		dma_cb_t cb2, void *, int);
 
 /*
  * Request specific SDMA SG channel (actually pair of channels)
@@ -311,11 +319,16 @@ int dma_request_sg_channel (char *, dma_cb_t cb, void *);
  *
  * Function parameters:
  * 1st parameter - SDMA channel number
- * 2nd parameter - free-form string identifier of channel.
- * 3rd parameter - callback function to be invoked when an interrupt
- *                 occurs for this channel
- * 4th parameter - additional data (callback-specific context) to be passed
- *                 to the callback function when it's invoked
+ * 2nd parameter - callback function to be invoked when an interrupt
+ *                 occurs for the first channel
+ * 3rd parameter - additional data (callback-specific context) to be passed
+ *                 to the callback function of first channel when it's invoked
+ * 4th parameter - callback function to be invoked when an interrupt
+ *                 occurs for the second channel
+ * 5th parameter - additional data (callback-specific context) to be passed
+ *                 to the callback function of second channel when it's invoked
+ * 6th parameter - flag to enable soft IRQ for this channel. Only 1 channel
+ *                 may be enabled with soft-irq.
  *
  * Callback parameters:
  * 1st parameter - channel number for which an IRQ occured
@@ -325,20 +338,21 @@ int dma_request_sg_channel (char *, dma_cb_t cb, void *);
  *
  * Returns: bigger channel number on success, otherwise negative error code
  */
-int dma_request_specific_sg_channel (int, char *, dma_cb_t cb, void *);
+int dma_request_specific_sg_channel (int, char *, dma_cb_t cb1, void *,
+		dma_cb_t cb2, void *, int);
 
 /*
  * Prepare SG list for programming into the SDMA controller
  * This function is intended to set right companion channel for each
- * entry in the list except the last one and to set the last entry of 
- * the scatter-gather list according to one of the methods to define 
+ * entry in the list except the last one and to set the last entry of
+ * the scatter-gather list according to one of the methods to define
  * the last entry described.
  *
  * Function parameters:
  * 1st parameter - channel number returned by dma_request_sg_channel()
  * 2nd parameter - ptr to the first scatter gather list entry
  *
- * Returns: 0 on success, otherwise failure 
+ * Returns: 0 on success, otherwise failure
  */
 int dma_prepare_sg_list(int, dma_sg_ll_t *);
 
@@ -348,10 +362,10 @@ int dma_prepare_sg_list(int, dma_sg_ll_t *);
  * the user has to supply only the linked-list address
  *
  * Function parameters:
- * 1st parameter - channel number returned by dma_request_sg_channel() 
+ * 1st parameter - channel number returned by dma_request_sg_channel()
  * 2nd parameter - physical ptr to the first entry in the linked list
  *
- * Returns: 0 on success, otherwise failure 
+ * Returns: 0 on success, otherwise failure
  */
 int dma_prog_sg_channel(int, u32 );
 
@@ -361,10 +375,18 @@ int dma_prog_sg_channel(int, u32 );
  * Function parameters:
  * 1st parameter - channel number returned by dma_request_sg_channel()
  *
- * Returns: 0 on success, otherwise failure 
+ * Returns: 0 on success, otherwise failure
  */
 int dma_release_sg_channel (unsigned int);
 
-#endif				/* _ASM_ARCH_DMA_H */
-
+/*
+ * Indicates if DMA channel is enabled
+ *
+ * Function parameters:
+ * 1st parameter - MA channel number
+ *
+ * Returns: 0 is disabled, otherwise !0
+ */
+int dma_channel_enabled(unsigned int);
 
+#endif				/* _ASM_ARCH_DMA_H */
diff --git a./target/linux/lpc313x/files/arch/arm/mach-lpc313x/include/mach/hardware.h b./target/linux/lpc313x/files/arch/arm/mach-lpc313x/include/mach/hardware.h
index 4a3f9b0..7feb42d 100644
--- a./target/linux/lpc313x/files/arch/arm/mach-lpc313x/include/mach/hardware.h
+++ b./target/linux/lpc313x/files/arch/arm/mach-lpc313x/include/mach/hardware.h
@@ -169,6 +169,12 @@
 #define I2C0_BASE_VIRT		(I2C0_BASE_PHYS+VIRT_OFFSET1)
 #define I2C0_LENGTH			0x00000030
 
+/* NAND address range*/
+#define IO_NAND_PHYS	  (NANDC_PHYS)
+#define IO_NAND_SIZE	  (0x00000800)
+/* NAND buffer address range*/
+#define IO_NAND_BUF_PHYS  (0x70000000)
+#define IO_NAND_BUF_SIZE  (0x00001000)
 
 /* glue for NXP headers */
 
diff --git a./target/linux/lpc313x/patches/timeconst.patch b./target/linux/lpc313x/patches/timeconst.patch
new file mode 100644
index 0000000..b8c3713
--- /dev/null
+++ b./target/linux/lpc313x/patches/timeconst.patch
@@ -0,0 +1,29 @@
+--- a/kernel/timeconst.pl	2010-12-09 22:29:45.000000000 +0100
++++ b/kernel/timeconst.pl	2022-07-04 19:48:09.010106423 +0200
+@@ -270,7 +270,7 @@
+ 	my($name, $val) = @_;
+ 	my $csuf;
+ 
+-	if (defined($val)) {
++	if ($val) {
+ 	    if ($name !~ /SHR/) {
+ 		$val = "U64_C($val)";
+ 	    }
+@@ -321,7 +321,7 @@
+ 	my @l = ();
+ 
+ 	foreach $v (@_) {
+-		if (!defined($v)) {
++		if (!$v) {
+ 			push(@l, 'undef');
+ 		} elsif ($v =~ /^0x/) {
+ 			push(@l, "\'".$v."\'");
+@@ -370,7 +370,7 @@
+ 	}
+ 
+ 	@val = @{$canned_values{$hz}};
+-	if (!defined(@val)) {
++	if (!@val) {
+ 		@val = compute_values($hz);
+ 	}
+ 	output($hz, @val);
diff --git a./target/linux/orion/base-files/lib/upgrade/platform.sh b./target/linux/orion/base-files/lib/upgrade/platform.sh
old mode 100644
new mode 100744
diff --git a./target/linux/ppc40x/base-files/lib/upgrade/platform.sh b./target/linux/ppc40x/base-files/lib/upgrade/platform.sh
old mode 100644
new mode 100744
diff --git a./target/linux/rb532/base-files/etc/diag.sh b./target/linux/rb532/base-files/etc/diag.sh
old mode 100644
new mode 100744
diff --git a./target/linux/rdc/base-files/etc/diag.sh b./target/linux/rdc/base-files/etc/diag.sh
old mode 100644
new mode 100744
diff --git a./target/linux/rdc/base-files/lib/upgrade/platform.sh b./target/linux/rdc/base-files/lib/upgrade/platform.sh
old mode 100644
new mode 100744
diff --git a./target/linux/x86/base-files/lib/upgrade/platform.sh b./target/linux/x86/base-files/lib/upgrade/platform.sh
old mode 100644
new mode 100744
diff --git a./target/linux/x86/olpc/base-files/lib/upgrade/platform.sh b./target/linux/x86/olpc/base-files/lib/upgrade/platform.sh
old mode 100644
new mode 100744
diff --git a./toolchain/uClibc/Config.in b./toolchain/uClibc/Config.in
index 670ba02..8dcdf38 100644
--- a./toolchain/uClibc/Config.in
+++ b./toolchain/uClibc/Config.in
@@ -3,10 +3,14 @@
 choice
 	prompt "uClibc Version"
 	depends on TOOLCHAINOPTS && USE_UCLIBC
-	default UCLIBC_VERSION_0_9_30_1
+#	default UCLIBC_VERSION_0_9_30_1
+	default UCLIBC_VERSION_0_9_29
 	help
 	  Select the version of uClibc you wish to use.
 
+	config UCLIBC_VERSION_0_9_29
+		bool "uClibc 0.9.29"
+
 	config UCLIBC_VERSION_0_9_30_1
 		bool "uClibc 0.9.30.1"
 
diff --git a./toolchain/uClibc/Config.version b./toolchain/uClibc/Config.version
index 5ecab96..354eee6 100644
--- a./toolchain/uClibc/Config.version
+++ b./toolchain/uClibc/Config.version
@@ -1,6 +1,7 @@
 config UCLIBC_VERSION
 	string
 	depends on USE_UCLIBC
+	default "0.9.29"       if UCLIBC_VERSION_0_9_29
 	default "0.9.30.1"     if UCLIBC_VERSION_0_9_30_1
 	default "0.9.30.2"     if UCLIBC_VERSION_0_9_30_2
 	default "0.9.30.3"     if UCLIBC_VERSION_0_9_30_3
diff --git a./toolchain/uClibc/config-0.9.29/arm b./toolchain/uClibc/config-0.9.29/arm
new file mode 100644
index 0000000..5af129d
--- /dev/null
+++ b./toolchain/uClibc/config-0.9.29/arm
@@ -0,0 +1,24 @@
+ARCH_ANY_ENDIAN=y
+ARCH_WANTS_LITTLE_ENDIAN=y
+# CONFIG_ARM10T is not set
+# CONFIG_ARM1136JF_S is not set
+# CONFIG_ARM1176JZF_S is not set
+# CONFIG_ARM1176JZ_S is not set
+# CONFIG_ARM610 is not set
+# CONFIG_ARM710 is not set
+# CONFIG_ARM720T is not set
+# CONFIG_ARM7TDMI is not set
+# CONFIG_ARM920T is not set
+# CONFIG_ARM922T is not set
+# CONFIG_ARM926T is not set
+CONFIG_ARM_EABI=y
+# CONFIG_ARM_IWMMXT is not set
+# CONFIG_ARM_OABI is not set
+# CONFIG_ARM_SA110 is not set
+# CONFIG_ARM_SA1100 is not set
+CONFIG_ARM_XSCALE=y
+# CONFIG_GENERIC_ARM is not set
+KERNEL_HEADERS="./toolchain_build_arm/linux/include"
+KERNEL_SOURCE="./toolchain_build_arm/linux"
+TARGET_ARCH="arm"
+TARGET_arm=y
diff --git a./toolchain/uClibc/config-0.9.29/arm.gemini b./toolchain/uClibc/config-0.9.29/arm.gemini
new file mode 100644
index 0000000..90d5b00
--- /dev/null
+++ b./toolchain/uClibc/config-0.9.29/arm.gemini
@@ -0,0 +1,25 @@
+ARCH_ANY_ENDIAN=y
+ARCH_WANTS_LITTLE_ENDIAN=y
+# CONFIG_ARM10T is not set
+# CONFIG_ARM1136JF_S is not set
+# CONFIG_ARM1176JZF_S is not set
+# CONFIG_ARM1176JZ_S is not set
+# CONFIG_ARM610 is not set
+# CONFIG_ARM710 is not set
+# CONFIG_ARM720T is not set
+# CONFIG_ARM7TDMI is not set
+CONFIG_ARM920T=y
+# CONFIG_ARM922T is not set
+# CONFIG_ARM926T is not set
+CONFIG_ARM_EABI=y
+# CONFIG_ARM_IWMMXT is not set
+# CONFIG_ARM_OABI is not set
+# CONFIG_ARM_SA110 is not set
+# CONFIG_ARM_SA1100 is not set
+# CONFIG_ARM_XSCALE is not set
+# CONFIG_GENERIC_ARM is not set
+KERNEL_HEADERS="./toolchain_build_arm/linux/include"
+KERNEL_SOURCE="./toolchain_build_arm/linux"
+TARGET_ARCH="arm"
+TARGET_arm=y
+# USE_BX is not set
diff --git a./toolchain/uClibc/config-0.9.29/arm.storm b./toolchain/uClibc/config-0.9.29/arm.storm
new file mode 100644
index 0000000..90d5b00
--- /dev/null
+++ b./toolchain/uClibc/config-0.9.29/arm.storm
@@ -0,0 +1,25 @@
+ARCH_ANY_ENDIAN=y
+ARCH_WANTS_LITTLE_ENDIAN=y
+# CONFIG_ARM10T is not set
+# CONFIG_ARM1136JF_S is not set
+# CONFIG_ARM1176JZF_S is not set
+# CONFIG_ARM1176JZ_S is not set
+# CONFIG_ARM610 is not set
+# CONFIG_ARM710 is not set
+# CONFIG_ARM720T is not set
+# CONFIG_ARM7TDMI is not set
+CONFIG_ARM920T=y
+# CONFIG_ARM922T is not set
+# CONFIG_ARM926T is not set
+CONFIG_ARM_EABI=y
+# CONFIG_ARM_IWMMXT is not set
+# CONFIG_ARM_OABI is not set
+# CONFIG_ARM_SA110 is not set
+# CONFIG_ARM_SA1100 is not set
+# CONFIG_ARM_XSCALE is not set
+# CONFIG_GENERIC_ARM is not set
+KERNEL_HEADERS="./toolchain_build_arm/linux/include"
+KERNEL_SOURCE="./toolchain_build_arm/linux"
+TARGET_ARCH="arm"
+TARGET_arm=y
+# USE_BX is not set
diff --git a./toolchain/uClibc/config-0.9.29/armeb b./toolchain/uClibc/config-0.9.29/armeb
new file mode 100644
index 0000000..d566d9a
--- /dev/null
+++ b./toolchain/uClibc/config-0.9.29/armeb
@@ -0,0 +1,25 @@
+ARCH_ANY_ENDIAN=y
+ARCH_BIG_ENDIAN=y
+ARCH_WANTS_BIG_ENDIAN=y
+# CONFIG_ARM10T is not set
+# CONFIG_ARM1136JF_S is not set
+# CONFIG_ARM1176JZF_S is not set
+# CONFIG_ARM1176JZ_S is not set
+# CONFIG_ARM610 is not set
+# CONFIG_ARM710 is not set
+# CONFIG_ARM720T is not set
+# CONFIG_ARM7TDMI is not set
+# CONFIG_ARM920T is not set
+# CONFIG_ARM922T is not set
+# CONFIG_ARM926T is not set
+CONFIG_ARM_EABI=y
+# CONFIG_ARM_IWMMXT is not set
+# CONFIG_ARM_OABI is not set
+# CONFIG_ARM_SA110 is not set
+# CONFIG_ARM_SA1100 is not set
+CONFIG_ARM_XSCALE=y
+# CONFIG_GENERIC_ARM is not set
+KERNEL_HEADERS="./toolchain_build_armeb/linux/include"
+KERNEL_SOURCE="./toolchain_build_armeb/linux"
+TARGET_ARCH="arm"
+TARGET_arm=y
diff --git a./toolchain/uClibc/config-0.9.29/avr32 b./toolchain/uClibc/config-0.9.29/avr32
new file mode 100644
index 0000000..71088e0
--- /dev/null
+++ b./toolchain/uClibc/config-0.9.29/avr32
@@ -0,0 +1,15 @@
+ARCH_BIG_ENDIAN=y
+# ARCH_HAS_NO_MMU is not set
+# ARCH_LITTLE_ENDIAN is not set
+ARCH_WANTS_BIG_ENDIAN=y
+CONFIG_AP7000=y
+FORCE_SHAREABLE_TEXT_SEGMENTS=y
+KERNEL_HEADERS="./toolchain_build_avr32/linux/include"
+KERNEL_SOURCE="./toolchain_build_avr32/linux/include"
+LINKRELAX=y
+TARGET_ARCH="avr32"
+TARGET_avr32=y
+UCLIBC_COMPLETELY_PIC=y
+# UCLIBC_HAS_SCANF_GLIBC_A_FLAG is not set
+# UCLIBC_HAS_STRING_ARCH_OPT is not set
+UNIX98PTY_ONLY=y
diff --git a./toolchain/uClibc/config-0.9.29/common b./toolchain/uClibc/config-0.9.29/common
new file mode 100644
index 0000000..840b73f
--- /dev/null
+++ b./toolchain/uClibc/config-0.9.29/common
@@ -0,0 +1,152 @@
+# ARCH_ANY_ENDIAN is not set
+ARCH_HAS_MMU=y
+# ARCH_HAS_NO_LDSO is not set
+ARCH_USE_MMU=y
+# ARCH_WANTS_BIG_ENDIAN is not set
+# ARCH_WANTS_LITTLE_ENDIAN is not set
+ASSUME_DEVPTS=y
+BUILD_UCLIBC_LDSO=y
+COMPAT_ATEXIT=y
+CROSS_COMPILER_PREFIX=""
+DEVEL_PREFIX="/usr/"
+# DL_FINI_CRT_COMPAT is not set
+# DOASSERTS is not set
+# DODEBUG is not set
+# DODEBUG_PT is not set
+# DOMULTI is not set
+DOPIC=y
+DOSTRIP=y
+DO_C99_MATH=y
+# EXTRA_WARNINGS is not set
+FORCE_OPTIONS_FOR_ARCH=y
+# FORCE_SHAREABLE_TEXT_SEGMENTS is not set
+# HAS_NO_THREADS is not set
+HAVE_DOT_CONFIG=y
+# HAVE_NO_PIC is not set
+# HAVE_NO_SHARED is not set
+# HAVE_NO_SSP is not set
+HAVE_SHARED=y
+KERNEL_HEADERS=""
+KERNEL_SOURCE=""
+LDSO_BASE_FILENAME="ld.so"
+LDSO_CACHE_SUPPORT=y
+LDSO_LDD_SUPPORT=y
+# LDSO_PRELOAD_FILE_SUPPORT is not set
+LDSO_RUNPATH=y
+LINUXTHREADS_OLD=y
+# MALLOC is not set
+MALLOC_GLIBC_COMPAT=y
+# MALLOC_SIMPLE is not set
+MALLOC_STANDARD=y
+# PTHREADS_DEBUG_SUPPORT is not set
+RUNTIME_PREFIX="/"
+SHARED_LIB_LOADER_PREFIX="/lib"
+# SUPPORT_LD_DEBUG is not set
+# SUPPORT_LD_DEBUG_EARLY is not set
+# TARGET_alpha is not set
+# TARGET_arm is not set
+# TARGET_avr32 is not set
+# TARGET_bfin is not set
+# TARGET_cris is not set
+# TARGET_e1 is not set
+# TARGET_frv is not set
+# TARGET_h8300 is not set
+# TARGET_hppa is not set
+# TARGET_i386 is not set
+# TARGET_i960 is not set
+# TARGET_ia64 is not set
+# TARGET_m68k is not set
+# TARGET_microblaze is not set
+# TARGET_mips is not set
+# TARGET_nios is not set
+# TARGET_nios2 is not set
+# TARGET_powerpc is not set
+# TARGET_sh is not set
+# TARGET_sh64 is not set
+# TARGET_sparc is not set
+# TARGET_v850 is not set
+# TARGET_vax is not set
+# TARGET_x86_64 is not set
+UCLIBC_BUILD_NOEXECSTACK=y
+# UCLIBC_BUILD_NOW is not set
+# UCLIBC_BUILD_PIE is not set
+UCLIBC_BUILD_RELRO=y
+UCLIBC_CTOR_DTOR=y
+UCLIBC_DYNAMIC_ATEXIT=y
+UCLIBC_EXTRA_CFLAGS=""
+UCLIBC_GRP_BUFFER_SIZE=256
+# UCLIBC_HAS_ARC4RANDOM is not set
+UCLIBC_HAS_BSD_RES_CLOSE=y
+UCLIBC_HAS_CTYPE_CHECKED=y
+# UCLIBC_HAS_CTYPE_ENFORCED is not set
+UCLIBC_HAS_CTYPE_SIGNED=y
+UCLIBC_HAS_CTYPE_TABLES=y
+# UCLIBC_HAS_CTYPE_UNSAFE is not set
+UCLIBC_HAS_ERRNO_MESSAGES=y
+UCLIBC_HAS_FLOATS=y
+UCLIBC_HAS_FNMATCH=y
+UCLIBC_HAS_FNMATCH_OLD=y
+UCLIBC_HAS_FOPEN_EXCLUSIVE_MODE=y
+# UCLIBC_HAS_FOPEN_LARGEFILE_MODE is not set
+UCLIBC_HAS_FPU=y
+UCLIBC_HAS_FTW=y
+UCLIBC_HAS_FULL_RPC=y
+UCLIBC_HAS_GLIBC_CUSTOM_PRINTF=y
+UCLIBC_HAS_GLIBC_CUSTOM_STREAMS=y
+UCLIBC_HAS_GLOB=y
+UCLIBC_HAS_GNU_GETOPT=y
+UCLIBC_HAS_GNU_GETSUBOPT=y
+UCLIBC_HAS_GNU_GLOB=y
+UCLIBC_HAS_HEXADECIMAL_FLOATS=y
+UCLIBC_HAS_IPV6=y
+UCLIBC_HAS_LFS=y
+# UCLIBC_HAS_LOCALE is not set
+UCLIBC_HAS_PRINTF_M_SPEC=y
+UCLIBC_HAS_PROGRAM_INVOCATION_NAME=y
+# UCLIBC_HAS_REENTRANT_RPC is not set
+UCLIBC_HAS_REGEX=y
+UCLIBC_HAS_REGEX_OLD=y
+UCLIBC_HAS_RPC=y
+UCLIBC_HAS_SCANF_GLIBC_A_FLAG=y
+UCLIBC_HAS_SHADOW=y
+UCLIBC_HAS_SIGNUM_MESSAGES=y
+UCLIBC_HAS_SOFT_FLOAT=y
+# UCLIBC_HAS_SSP is not set
+UCLIBC_HAS_STDIO_AUTO_RW_TRANSITION=y
+# UCLIBC_HAS_STDIO_BUFSIZ_1024 is not set
+# UCLIBC_HAS_STDIO_BUFSIZ_2048 is not set
+# UCLIBC_HAS_STDIO_BUFSIZ_256 is not set
+UCLIBC_HAS_STDIO_BUFSIZ_4096=y
+# UCLIBC_HAS_STDIO_BUFSIZ_512 is not set
+# UCLIBC_HAS_STDIO_BUFSIZ_8192 is not set
+# UCLIBC_HAS_STDIO_BUFSIZ_NONE is not set
+# UCLIBC_HAS_STDIO_BUILTIN_BUFFER_4 is not set
+# UCLIBC_HAS_STDIO_BUILTIN_BUFFER_8 is not set
+UCLIBC_HAS_STDIO_BUILTIN_BUFFER_NONE=y
+UCLIBC_HAS_STDIO_GETC_MACRO=y
+UCLIBC_HAS_STDIO_PUTC_MACRO=y
+# UCLIBC_HAS_STDIO_SHUTDOWN_ON_ABORT is not set
+UCLIBC_HAS_STRING_ARCH_OPT=y
+UCLIBC_HAS_STRING_GENERIC_OPT=y
+# UCLIBC_HAS_SYS_ERRLIST is not set
+# UCLIBC_HAS_SYS_SIGLIST is not set
+UCLIBC_HAS_THREADS=y
+UCLIBC_HAS_TM_EXTENSIONS=y
+UCLIBC_HAS_TZ_CACHING=y
+UCLIBC_HAS_TZ_FILE=y
+UCLIBC_HAS_TZ_FILE_READ_MANY=y
+UCLIBC_HAS_WCHAR=y
+UCLIBC_HAS_WORDEXP=y
+UCLIBC_HAS___PROGNAME=y
+# UCLIBC_MALLOC_DEBUGGING is not set
+# UCLIBC_MJN3_ONLY is not set
+UCLIBC_PRINTF_SCANF_POSITIONAL_ARGS=9
+UCLIBC_PWD_BUFFER_SIZE=256
+# UCLIBC_STATIC_LDCONFIG is not set
+# UCLIBC_SUSV3_LEGACY is not set
+UCLIBC_SUSV3_LEGACY_MACROS=y
+UCLIBC_TZ_FILE_PATH="/etc/TZ"
+UCLIBC_USE_NETLINK=y
+# UNIX98PTY_ONLY is not set
+USE_BX=y
+WARNINGS="-Wall"
diff --git a./toolchain/uClibc/config-0.9.29/cris b./toolchain/uClibc/config-0.9.29/cris
new file mode 100644
index 0000000..b94bd16
--- /dev/null
+++ b./toolchain/uClibc/config-0.9.29/cris
@@ -0,0 +1,8 @@
+ARCH_LITTLE_ENDIAN=y
+CONFIG_CRIS=y
+# CONFIG_CRISV32 is not set
+KERNEL_HEADERS="./toolchain_build_cris/linux"
+TARGET_ARCH="cris"
+TARGET_SUBARCH=""
+TARGET_cris=y
+UCLIBC_CTOR_DTOR=y 
diff --git a./toolchain/uClibc/config-0.9.29/i386 b./toolchain/uClibc/config-0.9.29/i386
new file mode 100644
index 0000000..75ef949
--- /dev/null
+++ b./toolchain/uClibc/config-0.9.29/i386
@@ -0,0 +1,23 @@
+ARCH_LITTLE_ENDIAN=y
+# CONFIG_386 is not set
+CONFIG_486=y
+# CONFIG_586 is not set
+# CONFIG_586MMX is not set
+# CONFIG_686 is not set
+# CONFIG_CRUSOE is not set
+# CONFIG_CYRIXIII is not set
+# CONFIG_ELAN is not set
+# CONFIG_GENERIC_386 is not set
+# CONFIG_K6 is not set
+# CONFIG_K7 is not set
+# CONFIG_NEHEMIAH is not set
+# CONFIG_PENTIUM4 is not set
+# CONFIG_PENTIUMII is not set
+# CONFIG_PENTIUMIII is not set
+# CONFIG_WINCHIP2 is not set
+# CONFIG_WINCHIPC6 is not set
+KERNEL_HEADERS="."
+# LINUXTHREADS_OLD is not set
+TARGET_ARCH="i386"
+TARGET_SUBARCH=""
+TARGET_i386=y
diff --git a./toolchain/uClibc/config-0.9.29/i686 b./toolchain/uClibc/config-0.9.29/i686
new file mode 100644
index 0000000..78b549a
--- /dev/null
+++ b./toolchain/uClibc/config-0.9.29/i686
@@ -0,0 +1,23 @@
+ARCH_LITTLE_ENDIAN=y
+# CONFIG_386 is not set
+# CONFIG_486 is not set
+# CONFIG_586 is not set
+# CONFIG_586MMX is not set
+CONFIG_686=y
+# CONFIG_CRUSOE is not set
+# CONFIG_CYRIXIII is not set
+# CONFIG_ELAN is not set
+# CONFIG_GENERIC_386 is not set
+# CONFIG_K6 is not set
+# CONFIG_K7 is not set
+# CONFIG_NEHEMIAH is not set
+# CONFIG_PENTIUM4 is not set
+# CONFIG_PENTIUMII is not set
+# CONFIG_PENTIUMIII is not set
+# CONFIG_WINCHIP2 is not set
+# CONFIG_WINCHIPC6 is not set
+KERNEL_HEADERS="."
+# LINUXTHREADS_OLD is not set
+TARGET_ARCH="i386"
+TARGET_SUBARCH=""
+TARGET_i386=y
diff --git a./toolchain/uClibc/config-0.9.29/mips b./toolchain/uClibc/config-0.9.29/mips
new file mode 100644
index 0000000..6d259d7
--- /dev/null
+++ b./toolchain/uClibc/config-0.9.29/mips
@@ -0,0 +1,19 @@
+ARCH_ANY_ENDIAN=y
+ARCH_BIG_ENDIAN=y
+ARCH_CFLAGS="-mno-split-addresses"
+# ARCH_LITTLE_ENDIAN is not set
+ARCH_WANTS_BIG_ENDIAN=y
+# CONFIG_MIPS_ISA_1 is not set
+# CONFIG_MIPS_ISA_2 is not set
+# CONFIG_MIPS_ISA_3 is not set
+# CONFIG_MIPS_ISA_4 is not set
+CONFIG_MIPS_ISA_MIPS32=y
+# CONFIG_MIPS_ISA_MIPS64 is not set
+# CONFIG_MIPS_N32_ABI is not set
+# CONFIG_MIPS_N64_ABI is not set
+CONFIG_MIPS_O32_ABI=y
+DL_FINI_CRT_COMPAT=y
+KERNEL_HEADERS="./toolchain_build_mips/linux/include"
+KERNEL_SOURCE="./toolchain_build_mips/linux"
+TARGET_ARCH="mips"
+TARGET_mips=y
diff --git a./toolchain/uClibc/config-0.9.29/mips64 b./toolchain/uClibc/config-0.9.29/mips64
new file mode 100644
index 0000000..5ec91ee
--- /dev/null
+++ b./toolchain/uClibc/config-0.9.29/mips64
@@ -0,0 +1,19 @@
+ARCH_ANY_ENDIAN=y
+ARCH_BIG_ENDIAN=y
+ARCH_CFLAGS="-mno-split-addresses"
+# ARCH_LITTLE_ENDIAN is not set
+ARCH_WANTS_BIG_ENDIAN=y
+# CONFIG_MIPS_ISA_1 is not set
+# CONFIG_MIPS_ISA_2 is not set
+# CONFIG_MIPS_ISA_3 is not set
+# CONFIG_MIPS_ISA_4 is not set
+# CONFIG_MIPS_ISA_MIPS32 is not set
+CONFIG_MIPS_ISA_MIPS64=y
+# CONFIG_MIPS_N32_ABI is not set
+CONFIG_MIPS_N64_ABI=y
+# CONFIG_MIPS_O32_ABI is not set
+DL_FINI_CRT_COMPAT=y
+KERNEL_HEADERS="."
+KERNEL_SOURCE="."
+TARGET_ARCH="mips"
+TARGET_mips=y
diff --git a./toolchain/uClibc/config-0.9.29/mips64el b./toolchain/uClibc/config-0.9.29/mips64el
new file mode 100644
index 0000000..0b6f5b4
--- /dev/null
+++ b./toolchain/uClibc/config-0.9.29/mips64el
@@ -0,0 +1,19 @@
+ARCH_ANY_ENDIAN=y
+# ARCH_BIG_ENDIAN is not set
+ARCH_CFLAGS="-mno-split-addresses"
+ARCH_LITTLE_ENDIAN=y
+ARCH_WANTS_LITTLE_ENDIAN=y
+# CONFIG_MIPS_ISA_1 is not set
+# CONFIG_MIPS_ISA_2 is not set
+# CONFIG_MIPS_ISA_3 is not set
+# CONFIG_MIPS_ISA_4 is not set
+# CONFIG_MIPS_ISA_MIPS32 is not set
+CONFIG_MIPS_ISA_MIPS64=y
+# CONFIG_MIPS_N32_ABI is not set
+CONFIG_MIPS_N64_ABI=y
+# CONFIG_MIPS_O32_ABI is not set
+DL_FINI_CRT_COMPAT=y
+KERNEL_HEADERS="."
+KERNEL_SOURCE="."
+TARGET_ARCH="mips"
+TARGET_mips=y
diff --git a./toolchain/uClibc/config-0.9.29/mipsel b./toolchain/uClibc/config-0.9.29/mipsel
new file mode 100644
index 0000000..c4a5ff8
--- /dev/null
+++ b./toolchain/uClibc/config-0.9.29/mipsel
@@ -0,0 +1,19 @@
+ARCH_ANY_ENDIAN=y
+# ARCH_BIG_ENDIAN is not set
+ARCH_CFLAGS="-mno-split-addresses"
+ARCH_LITTLE_ENDIAN=y
+ARCH_WANTS_LITTLE_ENDIAN=y
+# CONFIG_MIPS_ISA_1 is not set
+# CONFIG_MIPS_ISA_2 is not set
+# CONFIG_MIPS_ISA_3 is not set
+# CONFIG_MIPS_ISA_4 is not set
+CONFIG_MIPS_ISA_MIPS32=y
+# CONFIG_MIPS_ISA_MIPS64 is not set
+# CONFIG_MIPS_N32_ABI is not set
+# CONFIG_MIPS_N64_ABI is not set
+CONFIG_MIPS_O32_ABI=y
+DL_FINI_CRT_COMPAT=y
+KERNEL_HEADERS="./toolchain_build_mipsel/linux/include"
+KERNEL_SOURCE="./toolchain_build_mipsel/linux"
+TARGET_ARCH="mips"
+TARGET_mips=y
diff --git a./toolchain/uClibc/config-0.9.29/powerpc b./toolchain/uClibc/config-0.9.29/powerpc
new file mode 100644
index 0000000..407666b
--- /dev/null
+++ b./toolchain/uClibc/config-0.9.29/powerpc
@@ -0,0 +1,8 @@
+ARCH_BIG_ENDIAN=y
+# ARCH_LITTLE_ENDIAN is not set
+CONFIG_CLASSIC=y
+# CONFIG_E500 is not set
+KERNEL_HEADERS="./toolchain_build_powerpc/linux/include"
+KERNEL_SOURCE="./toolchain_build_powerpc/linux"
+TARGET_ARCH="powerpc"
+TARGET_powerpc=y
diff --git a./toolchain/uClibc/config-0.9.29/x86_64 b./toolchain/uClibc/config-0.9.29/x86_64
new file mode 100644
index 0000000..71a60b0
--- /dev/null
+++ b./toolchain/uClibc/config-0.9.29/x86_64
@@ -0,0 +1,5 @@
+ARCH_LITTLE_ENDIAN=y
+KERNEL_HEADERS="."
+TARGET_ARCH="x86_64"
+TARGET_SUBARCH=""
+TARGET_x86_64=y
diff --git a./toolchain/uClibc/patches-0.9.29/001-fix_mmap.patch b./toolchain/uClibc/patches-0.9.29/001-fix_mmap.patch
new file mode 100644
index 0000000..38cf60a
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/001-fix_mmap.patch
@@ -0,0 +1,91 @@
+--- /dev/null
++++ b/test/mmap/mmap2.c
+@@ -0,0 +1,41 @@
++/* When trying to map /dev/mem with offset 0xFFFFF000 on the ARM platform, mmap
++ * returns -EOVERFLOW.
++ *
++ * Since off_t is defined as a long int and the sign bit is set in the address,
++ * the shift operation shifts in ones instead of zeroes
++ * from the left. This results the offset sent to the kernel function becomes
++ * 0xFFFFFFFF instead of 0x000FFFFF with MMAP2_PAGE_SHIFT set to 12.
++ */
++
++#include <unistd.h>
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++#include <errno.h>
++#include <fcntl.h>
++#include <sys/mman.h>
++
++#define FATAL do { fprintf(stderr, "Error at line %d, file %s (%d) [%s]\n", \
++  __LINE__, __FILE__, errno, strerror(errno)); exit(1); } while(0)
++
++#define MAP_SIZE 4096UL
++#define MAP_MASK (MAP_SIZE - 1)
++
++int main(int argc, char **argv) {
++    void* map_base = 0;
++    int fd;
++    off_t target = 0xfffff000;
++    if((fd = open("/dev/mem", O_RDWR | O_SYNC)) == -1) FATAL;
++    printf("/dev/mem opened.\n");
++    fflush(stdout);
++
++   /* Map one page */
++    map_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,
++                        fd, target & ~MAP_MASK);
++    if(map_base == (void *) -1) FATAL;
++    printf("Memory mapped at address %p.\n", map_base);
++    fflush(stdout);
++    if(munmap(map_base, MAP_SIZE) == -1) FATAL;
++    close(fd);
++    return 0;
++}
+--- a/libc/sysdeps/linux/arm/mmap.c
++++ b/libc/sysdeps/linux/arm/mmap.c
+@@ -27,7 +27,6 @@ __ptr_t mmap(__ptr_t addr, size_t len, i
+ 
+ #elif defined  (__NR_mmap2)
+ #define __NR__mmap __NR_mmap2
+-
+ #ifndef MMAP2_PAGE_SHIFT
+ # define MMAP2_PAGE_SHIFT 12
+ #endif
+@@ -39,9 +38,17 @@ __ptr_t mmap(__ptr_t addr, size_t len, i
+ {
+   /* check if offset is page aligned */
+     if (offset & ((1 << MMAP2_PAGE_SHIFT) - 1))
++    {
++        __set_errno(EINVAL);
+         return MAP_FAILED;
++    }
++#ifdef __USE_FILE_OFFSET64
++  return (__ptr_t) _mmap (addr, len, prot, flags,
++						  fd,((__u_quad_t) offset >> MMAP2_PAGE_SHIFT));
++#else
+   return (__ptr_t) _mmap (addr, len, prot, flags,
+-						  fd,(off_t) (offset >> MMAP2_PAGE_SHIFT));
++                          fd,((__u_long) offset >> MMAP2_PAGE_SHIFT));
++#endif
+ }
+ #elif defined (__NR_mmap)
+ # define __NR__mmap __NR_mmap
+--- a/libc/sysdeps/linux/common/mmap64.c
++++ b/libc/sysdeps/linux/common/mmap64.c
+@@ -58,8 +58,13 @@ __ptr_t mmap64(__ptr_t addr, size_t len,
+ 		__set_errno(EINVAL);
+ 		return MAP_FAILED;
+ 	}
+-
+-	return __syscall_mmap2(addr, len, prot, flags, fd, (off_t) (offset >> MMAP2_PAGE_SHIFT));
++#ifdef __USE_FILE_OFFSET64
++  return __syscall_mmap2(addr, len, prot, flags,
++                         fd,((__u_quad_t)offset >> MMAP2_PAGE_SHIFT));
++#else
++   return __syscall_mmap2(addr, len, prot, flags,
++                          fd,((__u_long)offset >> MMAP2_PAGE_SHIFT));
++#endif
+ }
+ 
+ # endif
diff --git a./toolchain/uClibc/patches-0.9.29/002-conditional_sched_affinity.patch b./toolchain/uClibc/patches-0.9.29/002-conditional_sched_affinity.patch
new file mode 100644
index 0000000..dfd5bc9
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/002-conditional_sched_affinity.patch
@@ -0,0 +1,51 @@
+--- a/libc/sysdeps/linux/common/sched_getaffinity.c
++++ b/libc/sysdeps/linux/common/sched_getaffinity.c
+@@ -29,6 +29,7 @@
+ #include <sys/param.h>
+ #include <sys/types.h>
+ 
++#ifdef __NR_sched_getaffinity
+ libc_hidden_proto(memset)
+ 
+ #define __NR___syscall_sched_getaffinity __NR_sched_getaffinity
+@@ -48,5 +49,15 @@ int sched_getaffinity(pid_t pid, size_t 
+ 	}
+ 	return res;
+ }
++#else
++/*
++int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *cpuset)
++{
++	__set_errno(ENOSYS);
++	return -1;
++}
++*/
+ #endif
+ #endif
++
++#endif
+--- a/libc/sysdeps/linux/common/sched_setaffinity.c
++++ b/libc/sysdeps/linux/common/sched_setaffinity.c
+@@ -31,6 +31,7 @@
+ #include <sys/types.h>
+ #include <alloca.h>
+ 
++#ifdef __NR_sched_setaffinity
+ libc_hidden_proto(getpid)
+ 
+ #define __NR___syscall_sched_setaffinity __NR_sched_setaffinity
+@@ -74,5 +75,14 @@ int sched_setaffinity(pid_t pid, size_t 
+ 
+ 	return INLINE_SYSCALL (sched_setaffinity, 3, pid, cpusetsize, cpuset);
+ }
++#else
++/*
++int sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t *cpuset)
++{
++	__set_errno(ENOSYS);
++	return -1;
++}
++*/
++#endif
+ #endif
+ #endif
diff --git a./toolchain/uClibc/patches-0.9.29/004-fix_gethostent_r_failure_retval.patch b./toolchain/uClibc/patches-0.9.29/004-fix_gethostent_r_failure_retval.patch
new file mode 100644
index 0000000..0f4222c
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/004-fix_gethostent_r_failure_retval.patch
@@ -0,0 +1,11 @@
+--- a/libc/inet/resolv.c
++++ b/libc/inet/resolv.c
+@@ -1700,7 +1700,7 @@ void sethostent (int stay_open)
+ int gethostent_r(struct hostent *result_buf, char *buf, size_t buflen,
+ 	struct hostent **result, int *h_errnop)
+ {
+-    int ret;
++    int ret = HOST_NOT_FOUND;
+ 
+     __UCLIBC_MUTEX_LOCK(mylock);
+     if (__gethostent_fp == NULL) {
diff --git a./toolchain/uClibc/patches-0.9.29/005-fix_internal_function_definition.patch b./toolchain/uClibc/patches-0.9.29/005-fix_internal_function_definition.patch
new file mode 100644
index 0000000..fc66d1e
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/005-fix_internal_function_definition.patch
@@ -0,0 +1,47 @@
+--- a/libc/sysdeps/linux/i386/bits/uClibc_arch_features.h
++++ b/libc/sysdeps/linux/i386/bits/uClibc_arch_features.h
+@@ -42,6 +42,8 @@
+ /* define if target supports IEEE signed zero floats */
+ #define __UCLIBC_HAVE_SIGNED_ZERO__
+ 
++#if defined _LIBC
+ #define internal_function __attribute__ ((regparm (3), stdcall))
++#endif
+ 
+ #endif /* _BITS_UCLIBC_ARCH_FEATURES_H */
+--- a/include/libc-symbols.h
++++ b/include/libc-symbols.h
+@@ -22,6 +22,16 @@
+ #ifndef _LIBC_SYMBOLS_H
+ #define _LIBC_SYMBOLS_H	1
+ 
++/* This is defined for the compilation of all C library code.  features.h
++   tests this to avoid inclusion of stubs.h while compiling the library,
++   before stubs.h has been generated.  Some library code that is shared
++   with other packages also tests this symbol to see if it is being
++   compiled as part of the C library.  We must define this before including
++   config.h, because it makes some definitions conditional on whether libc
++   itself is being compiled, or just some generator program.  */
++#define _LIBC	1
++
++
+ /* This file's macros are included implicitly in the compilation of every
+    file in the C library by -imacros.
+ 
+@@ -40,16 +50,6 @@
+ 
+ #include <bits/uClibc_arch_features.h>
+ 
+-
+-/* This is defined for the compilation of all C library code.  features.h
+-   tests this to avoid inclusion of stubs.h while compiling the library,
+-   before stubs.h has been generated.  Some library code that is shared
+-   with other packages also tests this symbol to see if it is being
+-   compiled as part of the C library.  We must define this before including
+-   config.h, because it makes some definitions conditional on whether libc
+-   itself is being compiled, or just some generator program.  */
+-#define _LIBC	1
+-
+ /* Enable declarations of GNU extensions, since we are compiling them.  */
+ #define _GNU_SOURCE	1
+ 
diff --git a./toolchain/uClibc/patches-0.9.29/006-rm_whitespace.patch b./toolchain/uClibc/patches-0.9.29/006-rm_whitespace.patch
new file mode 100644
index 0000000..57b6d30
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/006-rm_whitespace.patch
@@ -0,0 +1,82 @@
+--- a/include/assert.h
++++ b/include/assert.h
+@@ -31,7 +31,7 @@
+ #define	_ASSERT_H	1
+ #include <features.h>
+ 
+-#if defined __cplusplus && __GNUC_PREREQ (2,95)
++#if defined __cplusplus && __GNUC_PREREQ(2,95)
+ # define __ASSERT_VOID_CAST static_cast<void>
+ #else
+ # define __ASSERT_VOID_CAST (void)
+@@ -59,13 +59,17 @@ __END_DECLS
+   (__ASSERT_VOID_CAST ((expr) ? 0 :					      \
+ 		       (__assert (__STRING(expr), __FILE__, __LINE__,    \
+ 				       __ASSERT_FUNCTION), 0)))
+-  
++
++/* Define some temporaries to workaround tinyx makedepend bug */
++#define	__GNUC_PREREQ_2_6	__GNUC_PREREQ(2, 6)
++#define	__GNUC_PREREQ_2_4	__GNUC_PREREQ(2, 4)
+ /* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
+    which contains the name of the function currently being defined.
+    This is broken in G++ before version 2.6.
+    C9x has a similar variable called __func__, but prefer the GCC one since
+    it demangles C++ function names.  */
+-# if defined __cplusplus ? __GNUC_PREREQ (2, 6) : __GNUC_PREREQ (2, 4)
++
++# if defined __cplusplus ? __GNUC_PREREQ_2_6 : __GNUC_PREREQ_2_4
+ #   define __ASSERT_FUNCTION	__PRETTY_FUNCTION__
+ # else
+ #  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
+--- a/include/complex.h
++++ b/include/complex.h
+@@ -33,7 +33,7 @@ __BEGIN_DECLS
+ /* We might need to add support for more compilers here.  But since ISO
+    C99 is out hopefully all maintained compilers will soon provide the data
+    types `float complex' and `double complex'.  */
+-#if __GNUC_PREREQ (2, 7) && !__GNUC_PREREQ (2, 97)
++#if __GNUC_PREREQ(2, 7) && !__GNUC_PREREQ(2, 97)
+ # define _Complex __complex__
+ #endif
+ 
+--- a/include/features.h
++++ b/include/features.h
+@@ -143,7 +143,7 @@
+ 
+ /* Convenience macros to test the versions of glibc and gcc.
+    Use them like this:
+-   #if __GNUC_PREREQ (2,8)
++   #if __GNUC_PREREQ(2,8)
+    ... code requiring gcc 2.8 or later ...
+    #endif
+    Note - they won't work for gcc1 or glibc1, since the _MINOR macros
+@@ -297,7 +297,7 @@
+ /* uClibc does not support _FORTIFY_SOURCE */
+ #undef _FORTIFY_SOURCE
+ #if defined _FORTIFY_SOURCE && _FORTIFY_SOURCE > 0 \
+-    && __GNUC_PREREQ (4, 1) && defined __OPTIMIZE__ && __OPTIMIZE__ > 0
++    && __GNUC_PREREQ(4, 1) && defined __OPTIMIZE__ && __OPTIMIZE__ > 0
+ # if _FORTIFY_SOURCE > 1
+ #  define __USE_FORTIFY_LEVEL 2
+ # else
+@@ -366,7 +366,7 @@
+ #endif	/* !ASSEMBLER */
+ 
+ /* Decide whether we can define 'extern inline' functions in headers.  */
+-#if __GNUC_PREREQ (2, 7) && defined __OPTIMIZE__ \
++#if __GNUC_PREREQ(2, 7) && defined __OPTIMIZE__ \
+     && !defined __OPTIMIZE_SIZE__ && !defined __NO_INLINE__
+ # define __USE_EXTERN_INLINES	1
+ #endif
+--- a/include/tgmath.h
++++ b/include/tgmath.h
+@@ -34,7 +34,7 @@
+    do not try this for now and instead concentrate only on GNU CC.  Once
+    we have more information support for other compilers might follow.  */
+ 
+-#if __GNUC_PREREQ (2, 7)
++#if __GNUC_PREREQ(2, 7)
+ 
+ # ifdef __NO_LONG_DOUBLE_MATH
+ #  define __tgml(fct) fct
diff --git a./toolchain/uClibc/patches-0.9.29/007-avr32.patch b./toolchain/uClibc/patches-0.9.29/007-avr32.patch
new file mode 100644
index 0000000..ac8c9ef
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/007-avr32.patch
@@ -0,0 +1,3377 @@
+--- a/Rules.mak
++++ b/Rules.mak
+@@ -313,6 +313,12 @@ ifeq ($(TARGET_ARCH),frv)
+ 	UCLIBC_LDSO=ld.so.1
+ endif
+ 
++ifeq ($(strip $(TARGET_ARCH)),avr32)
++	CPU_CFLAGS-$(CONFIG_AVR32_AP7)	+= -march=ap
++	CPU_CFLAGS-$(CONFIG_LINKRELAX)	+= -mrelax
++	CPU_LDFLAGS-$(CONFIG_LINKRELAX)	+= --relax
++endif
++
+ # Keep the check_gcc from being needlessly executed
+ ifndef PIEFLAG
+ ifneq ($(UCLIBC_BUILD_PIE),y)
+--- /dev/null
++++ b/extra/Configs/Config.avr32
+@@ -0,0 +1,31 @@
++#
++# For a description of the syntax of this configuration file,
++# see extra/config/Kconfig-language.txt
++#
++
++config TARGET_ARCH
++	string
++	default "avr32"
++
++config FORCE_OPTIONS_FOR_ARCH
++	bool
++	default y
++	select ARCH_BIG_ENDIAN
++	select FORCE_SHAREABLE_TEXT_SEGMENTS
++
++config ARCH_CFLAGS
++	string
++
++choice
++	prompt "Target CPU Type"
++	default CONFIG_AVR32_AP7
++
++config CONFIG_AVR32_AP7
++	bool "AVR32 AP7"
++	select ARCH_HAS_MMU
++
++endchoice
++
++config LINKRELAX
++	bool "Enable linker optimizations"
++	default y
+--- a/extra/Configs/Config.in
++++ b/extra/Configs/Config.in
+@@ -16,6 +16,9 @@ config TARGET_alpha
+ config TARGET_arm
+ 	bool "arm"
+ 
++config TARGET_avr32
++	bool "avr32"
++
+ config TARGET_bfin
+ 	bool "bfin"
+ 
+@@ -92,6 +95,10 @@ if TARGET_arm
+ source "extra/Configs/Config.arm"
+ endif
+ 
++if TARGET_avr32
++source "extra/Configs/Config.avr32"
++endif
++
+ if TARGET_bfin
+ source "extra/Configs/Config.bfin"
+ endif
+--- /dev/null
++++ b/extra/Configs/defconfigs/avr32
+@@ -0,0 +1 @@
++TARGET_avr32=y
+--- a/include/elf.h
++++ b/include/elf.h
+@@ -354,6 +354,8 @@ typedef struct
+ /* NIOS magic number - no EABI available.  */
+ #define EM_NIOS32	0xFEBB
+ 
++#define EM_AVR32	0x18ad
++
+ /* V850 backend magic number.  Written in the absense of an ABI.  */
+ #define EM_CYGNUS_V850 0x9080
+ 
+@@ -2828,6 +2830,55 @@ typedef Elf32_Addr Elf32_Conflict;
+ /* Keep this the last entry.  */
+ #define R_V850_NUM		25
+ 
++/* Atmel AVR32 relocations.  */
++#define R_AVR32_NONE		0
++#define R_AVR32_32		1
++#define R_AVR32_16		2
++#define R_AVR32_8		3
++#define R_AVR32_32_PCREL	4
++#define R_AVR32_16_PCREL	5
++#define R_AVR32_8_PCREL		6
++#define R_AVR32_DIFF32		7
++#define R_AVR32_DIFF16		8
++#define R_AVR32_DIFF8		9
++#define R_AVR32_GOT32		10
++#define R_AVR32_GOT16		11
++#define R_AVR32_GOT8		12
++#define R_AVR32_21S		13
++#define R_AVR32_16U		14
++#define R_AVR32_16S		15
++#define R_AVR32_8S		16
++#define R_AVR32_8S_EXT		17
++#define R_AVR32_22H_PCREL	18
++#define R_AVR32_18W_PCREL	19
++#define R_AVR32_16B_PCREL	20
++#define R_AVR32_16N_PCREL	21
++#define R_AVR32_14UW_PCREL	22
++#define R_AVR32_11H_PCREL	23
++#define R_AVR32_10UW_PCREL	24
++#define R_AVR32_9H_PCREL	25
++#define R_AVR32_9UW_PCREL	26
++#define R_AVR32_HI16		27
++#define R_AVR32_LO16		28
++#define R_AVR32_GOTPC		29
++#define R_AVR32_GOTCALL		30
++#define R_AVR32_LDA_GOT		31
++#define R_AVR32_GOT21S		32
++#define R_AVR32_GOT18SW		33
++#define R_AVR32_GOT16S		34
++#define R_AVR32_GOT7UW		35
++#define R_AVR32_32_CPENT	36
++#define R_AVR32_CPCALL		37
++#define R_AVR32_16_CP		38
++#define R_AVR32_9W_CP		39
++#define R_AVR32_RELATIVE	40
++#define R_AVR32_GLOB_DAT	41
++#define R_AVR32_JMP_SLOT	42
++#define R_AVR32_ALIGN		43
++#define R_AVR32_NUM		44
++
++/* AVR32 dynamic tags */
++#define DT_AVR32_GOTSZ		0x70000001 /* Total size of GOT in bytes */
+ 
+ /* Renesas H8/300 Relocations */
+ #define R_H8_NONE       0
+--- a/ldso/include/dl-string.h
++++ b/ldso/include/dl-string.h
+@@ -285,7 +285,8 @@ static __always_inline char * _dl_simple
+ /* On some arches constant strings are referenced through the GOT.
+  * This requires that load_addr must already be defined... */
+ #if defined(mc68000)  || defined(__arm__) || defined(__thumb__) || \
+-    defined(__mips__) || defined(__sh__)  || defined(__powerpc__)
++    defined(__mips__) || defined(__sh__)  || defined(__powerpc__) || \
++	defined(__avr32__)
+ # define CONSTANT_STRING_GOT_FIXUP(X) \
+ 	if ((X) < (const char *) load_addr) (X) += load_addr
+ # define NO_EARLY_SEND_STDERR
+--- a/ldso/include/dl-syscall.h
++++ b/ldso/include/dl-syscall.h
+@@ -55,69 +55,69 @@
+    dynamic linking at all, so we cannot return any error codes.
+    We just punt if there is an error. */
+ #define __NR__dl_exit __NR_exit
+-static inline _syscall1(void, _dl_exit, int, status);
++static __always_inline _syscall1(void, _dl_exit, int, status);
+ 
+ #define __NR__dl_close __NR_close
+-static inline _syscall1(int, _dl_close, int, fd);
++static __always_inline _syscall1(int, _dl_close, int, fd);
+ 
+ #define __NR__dl_open __NR_open
+-static inline _syscall3(int, _dl_open, const char *, fn, int, flags,
++static __always_inline _syscall3(int, _dl_open, const char *, fn, int, flags,
+                         __kernel_mode_t, mode);
+ 
+ #define __NR__dl_write __NR_write
+-static inline _syscall3(unsigned long, _dl_write, int, fd,
++static __always_inline _syscall3(unsigned long, _dl_write, int, fd,
+                         const void *, buf, unsigned long, count);
+ 
+ #define __NR__dl_read __NR_read
+-static inline _syscall3(unsigned long, _dl_read, int, fd,
++static __always_inline _syscall3(unsigned long, _dl_read, int, fd,
+                         const void *, buf, unsigned long, count);
+ 
+ #define __NR__dl_mprotect __NR_mprotect
+-static inline _syscall3(int, _dl_mprotect, const void *, addr,
++static __always_inline _syscall3(int, _dl_mprotect, const void *, addr,
+                         unsigned long, len, int, prot);
+ 
+ #define __NR__dl_stat __NR_stat
+-static inline _syscall2(int, _dl_stat, const char *, file_name,
++static __always_inline _syscall2(int, _dl_stat, const char *, file_name,
+                         struct stat *, buf);
+ 
+ #define __NR__dl_fstat __NR_fstat
+-static inline _syscall2(int, _dl_fstat, int, fd, struct stat *, buf);
++static __always_inline _syscall2(int, _dl_fstat, int, fd, struct stat *, buf);
+ 
+ #define __NR__dl_munmap __NR_munmap
+-static inline _syscall2(int, _dl_munmap, void *, start, unsigned long, length);
++static __always_inline _syscall2(int, _dl_munmap, void *, start, unsigned long, length);
+ 
+ #ifdef __NR_getxuid
+ # define __NR_getuid __NR_getxuid
+ #endif
+ #define __NR__dl_getuid __NR_getuid
+-static inline _syscall0(uid_t, _dl_getuid);
++static __always_inline _syscall0(uid_t, _dl_getuid);
+ 
+ #ifndef __NR_geteuid
+ # define __NR_geteuid __NR_getuid
+ #endif
+ #define __NR__dl_geteuid __NR_geteuid
+-static inline _syscall0(uid_t, _dl_geteuid);
++static __always_inline _syscall0(uid_t, _dl_geteuid);
+ 
+ #ifdef __NR_getxgid
+ # define __NR_getgid __NR_getxgid
+ #endif
+ #define __NR__dl_getgid __NR_getgid
+-static inline _syscall0(gid_t, _dl_getgid);
++static __always_inline _syscall0(gid_t, _dl_getgid);
+ 
+ #ifndef __NR_getegid
+ # define __NR_getegid __NR_getgid
+ #endif
+ #define __NR__dl_getegid __NR_getegid
+-static inline _syscall0(gid_t, _dl_getegid);
++static __always_inline _syscall0(gid_t, _dl_getegid);
+ 
+ #ifdef __NR_getxpid
+ # define __NR_getpid __NR_getxpid
+ #endif
+ #define __NR__dl_getpid __NR_getpid
+-static inline _syscall0(gid_t, _dl_getpid);
++static __always_inline _syscall0(gid_t, _dl_getpid);
+ 
+ #define __NR__dl_readlink __NR_readlink
+-static inline _syscall3(int, _dl_readlink, const char *, path, char *, buf,
++static __always_inline _syscall3(int, _dl_readlink, const char *, path, char *, buf,
+                         size_t, bufsiz);
+ 
+ #ifdef __UCLIBC_HAS_SSP__
+@@ -146,14 +146,14 @@ static inline _syscall2(int, _dl_gettime
+ #if defined(__UCLIBC_MMAP_HAS_6_ARGS__) && defined(__NR_mmap)
+ 
+ # define __NR__dl_mmap __NR_mmap
+-static inline _syscall6(void *, _dl_mmap, void *, start, size_t, length,
++static __always_inline _syscall6(void *, _dl_mmap, void *, start, size_t, length,
+                         int, prot, int, flags, int, fd, off_t, offset);
+ 
+ /* then try mmap2() */
+ #elif defined(__NR_mmap2)
+ 
+ # define __NR___syscall_mmap2       __NR_mmap2
+-static inline _syscall6(__ptr_t, __syscall_mmap2, __ptr_t, addr, size_t, len,
++static __always_inline _syscall6(__ptr_t, __syscall_mmap2, __ptr_t, addr, size_t, len,
+                         int, prot, int, flags, int, fd, off_t, offset);
+ 
+ /* Some architectures always use 12 as page shift for mmap2() eventhough the
+@@ -164,7 +164,7 @@ static inline _syscall6(__ptr_t, __sysca
+ # define MMAP2_PAGE_SHIFT 12
+ #endif
+ 
+-static inline void * _dl_mmap(void * addr, unsigned long size, int prot,
++static __always_inline void * _dl_mmap(void * addr, unsigned long size, int prot,
+                               int flags, int fd, unsigned long offset)
+ {
+ 	if (offset & ((1 << MMAP2_PAGE_SHIFT) - 1))
+@@ -177,8 +177,8 @@ static inline void * _dl_mmap(void * add
+ #elif defined(__NR_mmap)
+ 
+ # define __NR__dl_mmap_real __NR_mmap
+-static inline _syscall1(void *, _dl_mmap_real, unsigned long *, buffer);
+-static inline void * _dl_mmap(void * addr, unsigned long size, int prot,
++static __always_inline _syscall1(void *, _dl_mmap_real, unsigned long *, buffer);
++static __always_inline void * _dl_mmap(void * addr, unsigned long size, int prot,
+                               int flags, int fd, unsigned long offset)
+ {
+ 	unsigned long buffer[6];
+--- /dev/null
++++ b/ldso/ldso/avr32/dl-debug.h
+@@ -0,0 +1,45 @@
++/*
++ * AVR32 ELF shared libary loader support
++ *
++ * Copyright (C) 2005-2007 Atmel Corporation
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. The name of the above contributors may not be
++ *    used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++static const char *_dl_reltypes_tab[] = {
++    "R_AVR32_NONE",
++    "R_AVR32_32", "R_AVR32_16", "R_AVR32_8",
++    "R_AVR32_32_PCREL", "R_AVR32_16_PCREL", "R_AVR32_8_PCREL",
++    "R_AVR32_DIFF32", "R_AVR32_DIFF16", "R_AVR32_DIFF8",
++    "R_AVR32_GOT32", "R_AVR32_GOT16", "R_AVR32_GOT8",
++    "R_AVR32_21S", "R_AVR32_16U", "R_AVR32_16S", "R_AVR32_8S", "R_AVR32_8S_EXT",
++    "R_AVR32_22H_PCREL", "R_AVR32_18W_PCREL", "R_AVR32_16B_PCREL",
++    "R_AVR32_16N_PCREL", "R_AVR32_14UW_PCREL", "R_AVR32_11H_PCREL",
++    "R_AVR32_10UW_PCREL", "R_AVR32_9H_PCREL", "R_AVR32_9UW_PCREL",
++    "R_AVR32_HI16", "R_AVR32_LO16",
++    "R_AVR32_GOTPC", "R_AVR32_GOTCALL", "R_AVR32_LDA_GOT",
++    "R_AVR32_GOT21S", "R_AVR32_GOT18SW", "R_AVR32_GOT16S", "R_AVR32_GOT7UW",
++    "R_AVR32_32_CPENT", "R_AVR32_CPCALL", "R_AVR32_16_CP", "R_AVR32_9W_CP",
++    "R_AVR32_RELATIVE", "R_AVR32_GLOB_DAT", "R_AVR32_JMP_SLOT",
++    "R_AVR32_ALIGN",
++};
+--- /dev/null
++++ b/ldso/ldso/avr32/dl-startup.h
+@@ -0,0 +1,112 @@
++/*
++ * Architecture specific code used by dl-startup.c
++ *
++ * Copyright (C) 2005-2007 Atmel Corporation
++ *
++ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
++ */
++
++/* This is the library loader's main entry point. Let _dl_boot2 do its
++ * initializations and jump to the application's entry point
++ * afterwards. */
++asm(	"	.text\n"
++	"	.global	_start\n"
++	"	.type	_start,@function\n"
++	"_start:\n"
++	/* All arguments are on the stack initially */
++	"	mov	r12, sp\n"
++	"	rcall	_dl_start\n"
++	/* Returns user entry point in r12. Save it. */
++	"	mov	r0, r12\n"
++	/* We're PIC, so get the Global Offset Table */
++	"	lddpc	r6, .L_GOT\n"
++	".L_RGOT:\n"
++	"	rsub	r6, pc\n"
++	/* Adjust argc and argv according to _dl_skip_args */
++	"	ld.w	r1, r6[_dl_skip_args@got]\n"
++	"	ld.w	r1, r1[0]\n"
++	"	ld.w	r2, sp++\n"
++	"	sub	r2, r1\n"
++	"	add	sp, sp, r1 << 2\n"
++	"	st.w	--sp, r2\n"
++	/* Load the finalizer function */
++	"	ld.w	r12, r6[_dl_fini@got]\n"
++	/* Jump to the user's entry point */
++	"	mov	pc, r0\n\n"
++
++	"	.align	2\n"
++	".L_GOT:"
++	"	.long	.L_RGOT - _GLOBAL_OFFSET_TABLE_\n"
++	"	.size	_start, . - _start\n"
++	"	.previous\n");
++
++/* Get a pointer to the argv array.  On many platforms this can be just
++ * the address if the first argument, on other platforms we need to
++ * do something a little more subtle here. */
++#define GET_ARGV(ARGVP, ARGS) ARGVP = ((unsigned long *)ARGS + 1)
++
++
++/* We can't call functions before the GOT has been initialized */
++#define NO_FUNCS_BEFORE_BOOTSTRAP
++
++/*
++ * Relocate the GOT during dynamic loader bootstrap.  This will add
++ * the load address to all entries in the GOT, which is necessary
++ * because the linker doesn't generate R_AVR32_RELATIVE relocs for the
++ * GOT.
++ */
++static __always_inline
++void PERFORM_BOOTSTRAP_GOT(struct elf_resolve *tpnt)
++{
++	Elf32_Addr i, nr_got;
++	register Elf32_Addr *__r6 __asm__("r6");
++	Elf32_Addr *got = __r6;
++
++	nr_got = tpnt->dynamic_info[DT_AVR32_GOTSZ_IDX] / sizeof(*got);
++	for (i = 2; i < nr_got; i++)
++		got[i] += tpnt->loadaddr;
++}
++
++#define PERFORM_BOOTSTRAP_GOT(tpnt) PERFORM_BOOTSTRAP_GOT(tpnt)
++
++/* Handle relocation of the symbols in the dynamic loader. */
++static __always_inline
++void PERFORM_BOOTSTRAP_RELOC(ELF_RELOC *rpnt, unsigned long *reloc_addr,
++			     unsigned long symbol_addr,
++			     unsigned long load_addr, Elf32_Sym *symtab)
++{
++	switch(ELF32_R_TYPE(rpnt->r_info)) {
++	case R_AVR32_NONE:
++		break;
++	case R_AVR32_GLOB_DAT:
++	case R_AVR32_JMP_SLOT:
++		*reloc_addr = symbol_addr;
++		break;
++	case R_AVR32_RELATIVE:
++		SEND_STDERR_DEBUG("Applying RELATIVE relocation: ");
++		SEND_ADDRESS_STDERR_DEBUG(load_addr, 0);
++		SEND_STDERR_DEBUG(" + ");
++		SEND_ADDRESS_STDERR_DEBUG(rpnt->r_addend, 1);
++		*reloc_addr = load_addr + rpnt->r_addend;
++		break;
++	default:
++		SEND_STDERR("BOOTSTRAP_RELOC: unhandled reloc_type ");
++		SEND_NUMBER_STDERR(ELF32_R_TYPE(rpnt->r_info), 1);
++		SEND_STDERR("REL, SYMBOL, LOAD: ");
++		SEND_ADDRESS_STDERR(reloc_addr, 0);
++		SEND_STDERR(", ");
++		SEND_ADDRESS_STDERR(symbol_addr, 0);
++		SEND_STDERR(", ");
++		SEND_ADDRESS_STDERR(load_addr, 1);
++		_dl_exit(1);
++	}
++}
++
++/* Transfer control to the user's application, once the dynamic loader
++ * is done. This routine has to exit the current function, then call
++ * the _dl_elf_main function.
++ *
++ * Since our _dl_boot will simply call whatever is returned by
++ * _dl_boot2, we can just return the address we're supposed to
++ * call.  */
++#define START()	return _dl_elf_main;
+--- /dev/null
++++ b/ldso/ldso/avr32/dl-syscalls.h
+@@ -0,0 +1,6 @@
++/* We can't use the real errno in ldso, since it has not yet
++ * been dynamicly linked in yet. */
++#include "sys/syscall.h"
++extern int _dl_errno;
++#undef __set_errno
++#define __set_errno(X) {(_dl_errno) = (X);}
+--- /dev/null
++++ b/ldso/ldso/avr32/dl-sysdep.h
+@@ -0,0 +1,105 @@
++/*
++ * Various assembly language/system dependent hacks that are required
++ * so that we can minimize the amount of platform specific code.
++ *
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
++ */
++
++/* Define this if the system uses RELOCA. */
++#define ELF_USES_RELOCA
++
++#include <elf.h>
++
++#define ARCH_NUM 1
++#define DT_AVR32_GOTSZ_IDX	(DT_NUM + OS_NUM)
++
++#define ARCH_DYNAMIC_INFO(dpnt, dynamic, debug_addr)			\
++	do {								\
++		if (dpnt->d_tag == DT_AVR32_GOTSZ)			\
++			dynamic[DT_AVR32_GOTSZ_IDX] = dpnt->d_un.d_val;	\
++	} while (0)
++
++/* Initialization sequence for the application/library GOT. */
++#define INIT_GOT(GOT_BASE,MODULE)					\
++	do {								\
++		unsigned long i, nr_got;				\
++									\
++		GOT_BASE[0] = (unsigned long) _dl_linux_resolve;	\
++		GOT_BASE[1] = (unsigned long) MODULE;			\
++									\
++		/* Add load address displacement to all GOT entries */	\
++		nr_got = MODULE->dynamic_info[DT_AVR32_GOTSZ_IDX] / 4;	\
++		for (i = 2; i < nr_got; i++)				\
++			GOT_BASE[i] += (unsigned long)MODULE->loadaddr;	\
++	} while (0)
++
++#define do_rem(result, n, base)	((result) = (n) % (base))
++
++/* Here we define the magic numbers that this dynamic loader should accept */
++#define MAGIC1 EM_AVR32
++#undef MAGIC2
++
++/* Used for error messages */
++#define ELF_TARGET "AVR32"
++
++unsigned long _dl_linux_resolver(unsigned long got_offset, unsigned long *got);
++
++/* 4096 bytes alignment */
++#define PAGE_ALIGN 0xfffff000
++#define ADDR_ALIGN 0xfff
++#define OFFS_ALIGN 0x7ffff000
++
++#define elf_machine_type_class(type)				\
++	((type == R_AVR32_JMP_SLOT) * ELF_RTYPE_CLASS_PLT)
++
++/* AVR32 doesn't need any COPY relocs */
++#define DL_NO_COPY_RELOCS
++
++/* Return the link-time address of _DYNAMIC.  Conveniently, this is the
++   first element of the GOT.  This must be inlined in a function which
++   uses global data.  */
++static inline Elf32_Addr
++elf_machine_dynamic (void)
++{
++	register Elf32_Addr *got asm ("r6");
++	return *got;
++}
++
++/* Return the run-time load address of the shared object.  */
++static inline Elf32_Addr
++elf_machine_load_address (void)
++{
++	extern void __dl_start asm("_dl_start");
++	Elf32_Addr got_addr = (Elf32_Addr) &__dl_start;
++	Elf32_Addr pcrel_addr;
++
++	asm   ("	lddpc	%0, 2f\n"
++	       "1:	add	%0, pc\n"
++	       "	rjmp	3f\n"
++	       "	.align	2\n"
++	       "2:	.long	_dl_start - 1b\n"
++	       "3:\n"
++	       : "=r"(pcrel_addr) : : "cc");
++
++	return pcrel_addr - got_addr;
++}
++
++/*
++ * Perform any RELATIVE relocations specified by DT_RELCOUNT.
++ * Currently, we don't use that tag, but we might in the future as
++ * this would reduce the startup time somewhat (although probably not by much).
++ */
++static inline void
++elf_machine_relative (Elf32_Addr load_off, const Elf32_Addr rel_addr,
++		      Elf32_Word relative_count)
++{
++	Elf32_Rela *rpnt = (void *)rel_addr;
++
++	do {
++		Elf32_Addr *reloc_addr;
++		reloc_addr = (void *)(load_off + (rpnt++)->r_offset);
++		*reloc_addr = load_off + rpnt->r_addend;
++	} while (--relative_count);
++}
+--- /dev/null
++++ b/ldso/ldso/avr32/elfinterp.c
+@@ -0,0 +1,191 @@
++/*
++ * AVR32 ELF shared library loader suppport
++ *
++ * Copyright (C) 2004-2006 Atmel Corporation
++ *
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. The name of the above contributors may not be
++ *    used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++unsigned long _dl_linux_resolver(unsigned long got_offset, unsigned long *got)
++{
++	struct elf_resolve *tpnt = (struct elf_resolve *)got[1];
++	Elf32_Sym *sym;
++	unsigned long local_gotno;
++	unsigned long gotsym;
++	unsigned long new_addr;
++	char *strtab, *symname;
++	unsigned long *entry;
++	unsigned long sym_index = got_offset / 4;
++
++#if 0
++	local_gotno = tpnt->dynamic_info[DT_AVR32_LOCAL_GOTNO];
++	gotsym = tpnt->dynamic_info[DT_AVR32_GOTSYM];
++
++	sym = ((Elf32_Sym *)(tpnt->dynamic_info[DT_SYMTAB] + tpnt->loadaddr))
++		+ sym_index;
++	strtab = (char *)(tpnt->dynamic_info[DT_STRTAB] + tpnt->loadaddr);
++	symname = strtab + sym->st_name;
++
++#if 0
++	new_addr = (unsigned long) _dl_find_hash(strtab + sym->st_name,
++						 tpnt->symbol_scope, tpnt,
++						 resolver);
++#endif
++
++	entry = (unsigned long *)(got + local_gotno + sym_index - gotsym);
++	*entry = new_addr;
++#endif
++
++	return new_addr;
++}
++
++static int
++_dl_parse(struct elf_resolve *tpnt, struct dyn_elf *scope,
++	  unsigned long rel_addr, unsigned long rel_size,
++	  int (*reloc_func)(struct elf_resolve *tpnt, struct dyn_elf *scope,
++			    Elf32_Rela *rpnt, Elf32_Sym *symtab, char *strtab))
++{
++	Elf32_Sym *symtab;
++	Elf32_Rela *rpnt;
++	char *strtab;
++	int i;
++
++	rpnt = (Elf32_Rela *)rel_addr;
++	rel_size /= sizeof(Elf32_Rela);
++	symtab = (Elf32_Sym *)tpnt->dynamic_info[DT_SYMTAB];
++	strtab = (char *)tpnt->dynamic_info[DT_STRTAB];
++
++	for (i = 0; i < rel_size; i++, rpnt++) {
++		int symtab_index, res;
++
++		symtab_index = ELF32_R_SYM(rpnt->r_info);
++
++		debug_sym(symtab, strtab, symtab_index);
++		debug_reloc(symtab, strtab, rpnt);
++
++		res = reloc_func(tpnt, scope, rpnt, symtab, strtab);
++
++		if (res == 0)
++			continue;
++
++		_dl_dprintf(2, "\n%s: ", _dl_progname);
++
++		if (symtab_index)
++			_dl_dprintf(2, "symbol '%s': ",
++				    strtab + symtab[symtab_index].st_name);
++
++		if (res < 0) {
++			int reloc_type = ELF32_R_TYPE(rpnt->r_info);
++#if defined(__SUPPORT_LD_DEBUG__)
++			_dl_dprintf(2, "can't handle reloc type %s\n",
++				    _dl_reltypes(reloc_type));
++#else
++			_dl_dprintf(2, "can't handle reloc type %x\n",
++				    reloc_type);
++#endif
++			_dl_exit(-res);
++		} else {
++			_dl_dprintf(2, "can't resolve symbol\n");
++			return res;
++		}
++	}
++
++	return 0;
++}
++
++static int _dl_do_reloc(struct elf_resolve *tpnt, struct dyn_elf *scope,
++			Elf32_Rela *rpnt, Elf32_Sym *symtab, char *strtab)
++{
++	int reloc_type;
++	int symtab_index;
++	char *symname;
++	unsigned long *reloc_addr;
++	unsigned long symbol_addr;
++#if defined(__SUPPORT_LD_DEBUG__)
++	unsigned long old_val;
++#endif
++
++	reloc_addr = (unsigned long *)(tpnt->loadaddr + rpnt->r_offset);
++	reloc_type = ELF32_R_TYPE(rpnt->r_info);
++	symtab_index = ELF32_R_SYM(rpnt->r_info);
++	symbol_addr = 0;
++	symname = strtab + symtab[symtab_index].st_name;
++
++	if (symtab_index) {
++		symbol_addr = (unsigned long)
++			_dl_find_hash(strtab + symtab[symtab_index].st_name,
++				      tpnt->symbol_scope, tpnt,
++				      elf_machine_type_class(reloc_type));
++
++		/* Allow undefined references to weak symbols */
++		if (!symbol_addr &&
++		    ELF32_ST_BIND(symtab[symtab_index].st_info) != STB_WEAK) {
++			_dl_dprintf(2, "%s: can't resolve symbol '%s'\n",
++				    _dl_progname, symname);
++			return 0;
++		}
++	}
++
++#if defined(__SUPPORT_LD_DEBUG__)
++	old_val = *reloc_addr;
++#endif
++	switch (reloc_type) {
++	case R_AVR32_NONE:
++		break;
++	case R_AVR32_GLOB_DAT:
++	case R_AVR32_JMP_SLOT:
++		*reloc_addr = symbol_addr + rpnt->r_addend;
++		break;
++	case R_AVR32_RELATIVE:
++		*reloc_addr = (unsigned long)tpnt->loadaddr
++			+ rpnt->r_addend;
++		break;
++	default:
++		return -1;
++	}
++
++#if defined(__SUPPORT_LD_DEBUG__)
++	if (_dl_debug_reloc && _dl_debug_detail)
++		_dl_dprintf(_dl_debug_file, "\tpatched: %x ==> %x @ %x\n",
++			    old_val, *reloc_addr);
++#endif
++
++	return 0;
++}
++
++void _dl_parse_lazy_relocation_information(struct dyn_elf *rpnt,
++					   unsigned long rel_addr,
++					   unsigned long rel_size)
++{
++	/* TODO: Might want to support this in order to get faster
++	 * startup times... */
++}
++
++int _dl_parse_relocation_information(struct dyn_elf *rpnt,
++				     unsigned long rel_addr,
++				     unsigned long rel_size)
++{
++	return _dl_parse(rpnt->dyn, rpnt->dyn->symbol_scope, rel_addr, rel_size,
++			 _dl_do_reloc);
++}
+--- /dev/null
++++ b/ldso/ldso/avr32/resolve.S
+@@ -0,0 +1,28 @@
++/*
++ * Linux dynamic resolving code for AVR32. Fixes up the GOT entry as
++ * indicated in register r12 and jumps to the resolved address.
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ *
++ * Copyright (C) 2004-2007 Atmel Corporation
++ */
++
++#define ip r5
++
++	.text
++	.global	_dl_linux_resolve
++	.type	_dl_linux_resolve,@function
++_dl_linux_resolve:
++	/* The PLT code pushed r8 for us. It contains the address of this
++	   function's GOT entry, that is entry 0. ip contains the address
++	   of the GOT entry of the function we wanted to call. */
++	stm	--sp, r9-r12, lr
++	mov	r11, r8
++	sub	r12, ip, r8
++	rcall	_dl_linux_resolver
++	mov	ip, r12
++	popm	r8-r12,lr
++	mov	pc, ip
++	.size	_dl_linux_resolve, . - _dl_linux_resolve
+--- a/ldso/ldso/dl-startup.c
++++ b/ldso/ldso/dl-startup.c
+@@ -217,7 +217,9 @@ DL_START(unsigned long args)
+ 	/* some arches (like MIPS) we have to tweak the GOT before relocations */
+ 	PERFORM_BOOTSTRAP_GOT(tpnt);
+ 
+-#else
++#endif
++
++#if !defined(PERFORM_BOOTSTRAP_GOT) || defined(__avr32__)
+ 
+ 	/* OK, now do the relocations.  We do not do a lazy binding here, so
+ 	   that once we are done, we have considerably more flexibility. */
+--- a/libc/inet/resolv.c
++++ b/libc/inet/resolv.c
+@@ -1643,7 +1643,7 @@ int attribute_hidden __read_etc_hosts_r(
+ 			*result=result_buf;
+ 			ret=NETDB_SUCCESS;
+ #ifdef __UCLIBC_HAS_IPV6__
+-        } else if (type == AF_INET6 && inet_pton(AF_INET6, alias[0], in6) > 0) {
++		} else if (type == AF_INET6 && inet_pton(AF_INET6, alias[0], in6) > 0) {
+ 			DPRINTF("Found INET6\n");
+ 			addr_list6[0] = in6;
+ 			addr_list6[1] = 0;
+@@ -1658,8 +1658,8 @@ int attribute_hidden __read_etc_hosts_r(
+ 		} else {
+ 			DPRINTF("Error\n");
+ 			ret=TRY_AGAIN;
+-			break; /* bad ip address */
+-        }
++			continue; /* bad ip address, keep searching */
++		}
+ 
+ 		if (action!=GETHOSTENT) {
+ 			fclose(fp);
+--- /dev/null
++++ b/libc/string/avr32/Makefile
+@@ -0,0 +1,26 @@
++# Makefile for uClibc
++#
++# Copyright (C) 2000-2003 Erik Andersen <andersen@uclibc.org>
++#
++# This program is free software; you can redistribute it and/or modify it under
++# the terms of the GNU Library General Public License as published by the Free
++# Software Foundation; either version 2 of the License, or (at your option) any
++# later version.
++#
++# This program is distributed in the hope that it will be useful, but WITHOUT
++# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
++# FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
++# details.
++#
++# You should have received a copy of the GNU Library General Public License
++# along with this program; if not, write to the Free Software Foundation, Inc.,
++# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++
++top_srcdir	:= ../../../
++top_builddir	:= ../../../
++
++all: objs
++
++include $(top_builddir)Rules.mak
++include ../Makefile.in
++include $(top_srcdir)Makerules
+--- /dev/null
++++ b/libc/string/avr32/bcopy.S
+@@ -0,0 +1,26 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++
++#include <features.h>
++
++#ifdef __UCLIBC_SUSV3_LEGACY__
++
++	.text
++	.global bcopy
++	.type	bcopy, @function
++	.align	1
++bcopy:
++	/* Swap the first two arguments */
++	eor	r11, r12
++	eor	r12, r11
++	eor	r11, r12
++	rjmp	__GI_memmove
++
++	.size	bcopy, . - bcopy
++
++#endif /* __UCLIBC_SUSV3_LEGACY__ */
+--- /dev/null
++++ b/libc/string/avr32/bzero.S
+@@ -0,0 +1,22 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++
++#ifdef __UCLIBC_SUSV3_LEGACY__
++
++	.text
++	.global bzero
++	.type	bzero, @function
++	.align	1
++bzero:
++	mov	r10, r11
++	mov	r11, 0
++	rjmp	__memset
++
++	.size	bzero, . - bzero
++
++#endif /* __UCLIBC_SUSV3_LEGACY__ */
+--- /dev/null
++++ b/libc/string/avr32/memcmp.S
+@@ -0,0 +1,61 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++
++#include <features.h>
++
++#define s1 r12
++#define s2 r11
++#define len r10
++
++	.text
++	.global memcmp
++	.type	memcmp, @function
++	.align	1
++memcmp:
++	sub	len, 4
++	brlt	.Lless_than_4
++
++1:	ld.w	r8, s1++
++	ld.w	r9, s2++
++	cp.w	r8, r9
++	brne	.Lfound_word
++	sub	len, 4
++	brge	1b
++
++.Lless_than_4:
++	sub	len, -4
++	reteq	0
++
++1:	ld.ub	r8, s1++
++	ld.ub	r9, s2++
++	sub	r8, r9
++	retne	r8
++	sub	len, 1
++	brgt	1b
++
++	retal	0
++
++.Lfound_word:
++	mov	len, 4
++
++2:	bfextu	r11, r9, 24, 8
++	bfextu	r12, r8, 24, 8
++	sub	r12, r11
++	retne	r12
++	lsl	r8, 8
++	lsl	r9, 8
++	sub	len, 1
++	brne	2b
++	retal	r12
++
++	.size	memcmp, . - memcmp
++
++libc_hidden_def(memcmp)
++#ifdef __UCLIBC_SUSV3_LEGACY__
++strong_alias(memcmp,bcmp)
++#endif
+--- /dev/null
++++ b/libc/string/avr32/memcpy.S
+@@ -0,0 +1,111 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++
++/* Don't use r12 as dst since we must return it unmodified */
++#define dst r9
++#define src r11
++#define len r10
++
++	.text
++	.global	memcpy
++	.type	memcpy, @function
++memcpy:
++	pref	src[0]
++	mov	dst, r12
++
++	/* If we have less than 32 bytes, don't do anything fancy */
++	cp.w	len, 32
++	brge	.Lmore_than_31
++
++	sub	len, 1
++	retlt	r12
++1:	ld.ub	r8, src++
++	st.b	dst++, r8
++	sub	len, 1
++	brge	1b
++	retal	r12
++
++.Lmore_than_31:
++	pushm	r0-r7, lr
++
++	/* Check alignment */
++	mov	r8, src
++	andl	r8, 31, COH
++	brne	.Lunaligned_src
++	mov	r8, dst
++	andl	r8, 3, COH
++	brne	.Lunaligned_dst
++
++.Laligned_copy:
++	sub	len, 32
++	brlt	.Lless_than_32
++
++1:	/* Copy 32 bytes at a time */
++	ldm	src, r0-r7
++	sub	src, -32
++	stm	dst, r0-r7
++	sub	dst, -32
++	sub	len, 32
++	brge	1b
++
++.Lless_than_32:
++	/* Copy 16 more bytes if possible */
++	sub	len, -16
++	brlt	.Lless_than_16
++	ldm	src, r0-r3
++	sub	src, -16
++	sub	len, 16
++	stm	dst, r0-r3
++	sub	dst, -16
++
++.Lless_than_16:
++	/* Do the remaining as byte copies */
++	neg	len
++	add	pc, pc, len << 2
++	.rept	15
++	ld.ub	r0, src++
++	st.b	dst++, r0
++	.endr
++
++	popm	r0-r7, pc
++
++.Lunaligned_src:
++	/* Make src cacheline-aligned. r8 = (src & 31) */
++	rsub	r8, r8, 32
++	sub	len, r8
++1:	ld.ub	r0, src++
++	st.b	dst++, r0
++	sub	r8, 1
++	brne	1b
++
++	/* If dst is word-aligned, we're ready to go */
++	pref	src[0]
++	mov	r8, 3
++	tst	dst, r8
++	breq	.Laligned_copy
++
++.Lunaligned_dst:
++	/* src is aligned, but dst is not. Expect bad performance */
++	sub	len, 4
++	brlt	2f
++1:	ld.w	r0, src++
++	st.w	dst++, r0
++	sub	len, 4
++	brge	1b
++
++2:	neg	len
++	add	pc, pc, len << 2
++	.rept	3
++	ld.ub	r0, src++
++	st.b	dst++, r0
++	.endr
++
++	popm	r0-r7, pc
++	.size	memcpy, . - memcpy
++
++libc_hidden_def(memcpy)
+--- /dev/null
++++ b/libc/string/avr32/memmove.S
+@@ -0,0 +1,116 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++
++#define dst r12
++#define src r11
++#define len r10
++
++	.text
++	.global memmove
++	.type	memmove, @function
++memmove:
++	cp.w	src, dst
++	brge	__GI_memcpy
++
++	add	dst, len
++	add	src, len
++	pref	src[-1]
++
++	/*
++	 * The rest is basically the same as in memcpy.S except that
++	 * the direction is reversed.
++	 */
++	cp.w	len, 32
++	brge	.Lmore_than_31
++
++	sub	len, 1
++	retlt	r12
++1:	ld.ub	r8, --src
++	st.b	--dst, r8
++	sub	len, 1
++	brge	1b
++	retal	r12
++
++.Lmore_than_31:
++	pushm	r0-r7, lr
++
++	/* Check alignment */
++	mov	r8, src
++	andl	r8, 31, COH
++	brne	.Lunaligned_src
++	mov	r8, r12
++	andl	r8, 3, COH
++	brne	.Lunaligned_dst
++
++.Laligned_copy:
++	sub	len, 32
++	brlt	.Lless_than_32
++
++1:	/* Copy 32 bytes at a time */
++	sub	src, 32
++	ldm	src, r0-r7
++	sub	dst, 32
++	sub	len, 32
++	stm	dst, r0-r7
++	brge	1b
++
++.Lless_than_32:
++	/* Copy 16 more bytes if possible */
++	sub	len, -16
++	brlt	.Lless_than_16
++	sub	src, 16
++	ldm	src, r0-r3
++	sub	dst, 16
++	sub	len, 16
++	stm	dst, r0-r3
++
++.Lless_than_16:
++	/* Do the remaining as byte copies */
++	sub	len, -16
++	breq	2f
++1:	ld.ub	r0, --src
++	st.b	--dst, r0
++	sub	len, 1
++	brne	1b
++
++2:	popm	r0-r7, pc
++
++.Lunaligned_src:
++	/* Make src cacheline-aligned. r8 = (src & 31) */
++	sub	len, r8
++1:	ld.ub	r0, --src
++	st.b	--dst, r0
++	sub	r8, 1
++	brne	1b
++
++	/* If dst is word-aligned, we're ready to go */
++	pref	src[-4]
++	mov	r8, 3
++	tst	dst, r8
++	breq	.Laligned_copy
++
++.Lunaligned_dst:
++	/* src is aligned, but dst is not. Expect bad performance */
++	sub	len, 4
++	brlt	2f
++1:	ld.w	r0, --src
++	st.w	--dst, r0
++	sub	len, 4
++	brge	1b
++
++2:	neg	len
++	add	pc, pc, len << 2
++	.rept	3
++	ld.ub	r0, --src
++	st.b	--dst, r0
++	.endr
++
++	popm	r0-r7, pc
++	.size	memmove, . - memmove
++
++libc_hidden_def(memmove)
+--- /dev/null
++++ b/libc/string/avr32/memset.S
+@@ -0,0 +1,70 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++
++#include <features.h>
++
++#define s r12
++#define c r11
++#define n r10
++
++	.text
++	.global memset
++	.type	memset, @function
++
++	.global	__memset
++	.hidden	__memset
++	.type	__memset, @function
++
++	.align	1
++memset:
++__memset:
++	cp.w	n, 32
++	mov	r9, s
++	brge	.Llarge_memset
++
++	sub	n, 1
++	retlt	s
++1:	st.b	s++, c
++	sub	n, 1
++	brge	1b
++
++	retal	r9
++
++.Llarge_memset:
++	mov	r8, r11
++	mov	r11, 3
++	bfins	r8, r8, 8, 8
++	bfins	r8, r8, 16, 16
++	tst	s, r11
++	breq	2f
++
++1:	st.b	s++, r8
++	sub	n, 1
++	tst	s, r11
++	brne	1b
++
++2:	mov	r11, r9
++	mov	r9, r8
++	sub	n, 8
++
++3:	st.d	s++, r8
++	sub	n, 8
++	brge	3b
++
++	/* If we are done, n == -8 and we'll skip all st.b insns below */
++	neg	n
++	lsl	n, 1
++	add	pc, n
++	.rept	7
++	st.b	s++, r8
++	.endr
++	retal	r11
++
++	.size	memset, . - memset
++
++libc_hidden_def(memset)
+--- /dev/null
++++ b/libc/string/avr32/strcmp.S
+@@ -0,0 +1,91 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++
++#include <features.h>
++
++#define s1 r12
++#define s2 r11
++#define len r10
++
++	.text
++	.global strcmp
++	.type	strcmp, @function
++	.align	1
++strcmp:
++	mov	r8, 3
++	tst	s1, r8
++	brne	.Lunaligned_s1
++	tst	s2, r8
++	brne	.Lunaligned_s2
++
++1:	ld.w	r8, s1++
++	ld.w	r9, s2++
++	cp.w	r8, r9
++	brne	2f
++	tnbz	r8
++	brne	1b
++	retal	0
++
++2:	bfextu	r12, r8, 24, 8
++	bfextu	r11, r9, 24, 8
++	sub	r12, r11
++	retne	r12
++	cp.w	r11, 0
++	reteq	0
++	bfextu	r12, r8, 16, 8
++	bfextu	r11, r9, 16, 8
++	sub	r12, r11
++	retne	r12
++	cp.w	r11, 0
++	reteq	0
++	bfextu	r12, r8, 8, 8
++	bfextu	r11, r9, 8, 8
++	sub	r12, r11
++	retne	r12
++	cp.w	r11, 0
++	reteq	0
++	bfextu	r12, r8, 0, 8
++	bfextu	r11, r9, 0, 8
++	sub	r12, r11
++	retal	r12
++
++.Lunaligned_s1:
++3:	tst	s1, r8
++	breq	4f
++	ld.ub	r10, s1++
++	ld.ub	r9, s2++
++	sub	r10, r9
++	retne	r10
++	cp.w	r9, 0
++	brne	3b
++	retal	r10
++
++4:	tst	s2, r8
++	breq	1b
++
++.Lunaligned_s2:
++	/*
++	 * s1 and s2 can't both be aligned, and unaligned word loads
++	 * can trigger spurious exceptions if we cross a page boundary.
++	 * Do it the slow way...
++	 */
++1:	ld.ub	r8, s1++
++	ld.ub	r9, s2++
++	sub	r8, r9
++	retne	r8
++	cp.w	r9, 0
++	brne	1b
++	retal	0
++
++	.size	strcmp, . - strcmp
++
++libc_hidden_def(strcmp)
++#ifndef __UCLIBC_HAS_LOCALE__
++strong_alias(strcmp, strcoll)
++libc_hidden_def(strcoll)
++#endif
+--- /dev/null
++++ b/libc/string/avr32/strlen.S
+@@ -0,0 +1,62 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++
++#include <features.h>
++
++#define str r12
++
++	.text
++	.global strlen
++	.type	strlen, @function
++strlen:
++	mov	r11, r12
++
++	mov	r9, str
++	andl	r9, 3, COH
++	brne	.Lunaligned_str
++
++1:	ld.w	r8, str++
++	tnbz	r8
++	brne	1b
++
++	sub	r12, r11
++	bfextu	r9, r8, 24, 8
++	cp.w	r9, 0
++	subeq	r12, 4
++	reteq	r12
++	bfextu	r9, r8, 16, 8
++	cp.w	r9, 0
++	subeq	r12, 3
++	reteq	r12
++	bfextu	r9, r8, 8, 8
++	cp.w	r9, 0
++	subeq	r12, 2
++	reteq	r12
++	sub	r12, 1
++	retal	r12
++
++.Lunaligned_str:
++	add	pc, pc, r9 << 3
++	sub	r0, r0, 0	/* 4-byte nop */
++	ld.ub	r8, str++
++	sub	r8, r8, 0
++	breq	1f
++	ld.ub	r8, str++
++	sub	r8, r8, 0
++	breq	1f
++	ld.ub	r8, str++
++	sub	r8, r8, 0
++	brne	1b
++
++1:	sub	r12, 1
++	sub	r12, r11
++	retal	r12
++
++	.size	strlen, . - strlen
++
++libc_hidden_def(strlen)
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/Makefile
+@@ -0,0 +1,25 @@
++# Makefile for uClibc
++#
++# Copyright (C) 2000-2003 Erik Andersen <andersen@uclibc.org>
++#
++# This program is free software; you can redistribute it and/or modify it under
++# the terms of the GNU Library General Public License as published by the Free
++# Software Foundation; either version 2 of the License, or (at your option) any
++# later version.
++#
++# This program is distributed in the hope that it will be useful, but WITHOUT
++# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
++# FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
++# details.
++#
++# You should have received a copy of the GNU Library General Public License
++# along with this program; if not, write to the Free Software Foundation, Inc.,
++# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++
++top_srcdir=../../../../
++top_builddir=../../../../
++all: objs
++
++include $(top_builddir)Rules.mak
++include Makefile.arch
++include $(top_srcdir)Makerules
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/Makefile.arch
+@@ -0,0 +1,13 @@
++# Makefile for uClibc
++#
++# Copyright (C) 2000-2005 Erik Andersen <andersen@uclibc.org>
++#
++# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
++#
++
++CSRC	:= brk.c clone.c mmap.c sigaction.c
++
++SSRC	:= __longjmp.S setjmp.S bsd-setjmp.S bsd-_setjmp.S	\
++		sigrestorer.S syscall.S vfork.S
++
++include $(top_srcdir)/libc/sysdeps/linux/Makefile.commonarch
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/__longjmp.S
+@@ -0,0 +1,21 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++
++	.global	__longjmp
++	.type	__longjmp,"function"
++	.align	1
++__longjmp:
++	ldm	r12++, r0-r8,sp,lr
++	mustr	r8		/* restore status register (lower half) */
++	cp	r11, 0		/* can't return zero */
++	frs
++	moveq	r11, 1
++	retal	r11
++	.size	__longjmp, . - __longjmp
++
++libc_hidden_def(__longjmp)
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/bits/atomic.h
+@@ -0,0 +1,120 @@
++/*
++ * Copyright (C) 2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++#ifndef _AVR32_BITS_ATOMIC_H
++#define _AVR32_BITS_ATOMIC_H 1
++
++#include <inttypes.h>
++
++typedef int32_t atomic32_t;
++typedef uint32_t uatomic32_t;
++typedef int_fast32_t atomic_fast32_t;
++typedef uint_fast32_t uatomic_fast32_t;
++
++typedef intptr_t atomicptr_t;
++typedef uintptr_t uatomicptr_t;
++typedef intmax_t atomic_max_t;
++typedef uintmax_t uatomic_max_t;
++
++#define __arch_compare_and_exchange_val_8_acq(mem, newval, oldval)	\
++	(abort(), 0)
++
++#define __arch_compare_and_exchange_val_16_acq(mem, newval, oldval)	\
++	(abort(), 0)
++
++#define __arch_compare_and_exchange_val_32_acq(mem, newval, oldval)	\
++	({								\
++		__typeof__(*(mem)) __prev;				\
++		__asm__ __volatile__(					\
++			"/* __arch_compare_and_exchange_val_32_acq */\n" \
++			"1:	ssrf	5\n"				\
++			"	ld.w	%[result], %[m]\n"		\
++			"	cp.w	%[result], %[old]\n"		\
++			"	brne	2f\n"				\
++			"	stcond	%[m], %[new]\n"			\
++			"	brne	1b\n"				\
++			"2:"						\
++			: [result] "=&r"(__result), [m] "=m"(*(mem))	\
++			: "m"(*(mem)), [old] "ir"(oldval),		\
++			  [new] "r"(newval)				\
++			: "memory", "cc");				\
++		__prev;							\
++	})
++
++#define __arch_compare_and_exchange_val_64_acq(mem, newval, oldval)	\
++	(abort(), 0)
++
++#define __arch_exchange_32_acq(mem, newval)				\
++	({								\
++		__typeof__(*(mem)) __oldval;				\
++		__asm__ __volatile__(					\
++			"/*__arch_exchange_32_acq */\n"			\
++			"	xchg	%[old], %[m], %[new]"		\
++			: [old] "=&r"(__oldval)				\
++			: [m] "r"(mem), [new] "r"(newval)		\
++			: "memory");					\
++		__oldval;						\
++	})
++
++#define __arch_atomic_exchange_and_add_32(mem, value)			\
++	({								\
++		__typeof__(*(mem)) __oldval, __tmp;			\
++		__asm__ __volatile__(					\
++			"/* __arch_atomic_exchange_and_add_32 */\n"	\
++			"1:	ssrf	5\n"				\
++			"	ld.w	%[old], %[m]\n"			\
++			"	add	%[tmp], %[old], %[val]\n"	\
++			"	stcond	%[m], %[tmp]\n"			\
++			"	brne	1b"				\
++			: [old] "=&r"(__oldval), [tmp] "=&r"(__tmp),	\
++			  [m] "=m"(*(mem))				\
++			: "m"(*(mem)), [val] "r"(value)			\
++			: "memory", "cc");				\
++		__oldval;						\
++	})
++
++#define __arch_atomic_decrement_if_positive_32(mem)			\
++	({								\
++		__typeof__(*(mem)) __oldval, __tmp;			\
++		__asm__ __volatile__(					\
++			"/* __arch_atomic_decrement_if_positive_32 */\n" \
++			"1:	ssrf	5\n"				\
++			"	ld.w	%[old], %[m]\n"			\
++			"	sub	%[tmp], %[old], 1\n"		\
++			"	brlt	2f\n"				\
++			"	stcond	%[m], %[tmp]\n"			\
++			"	brne	1b"				\
++			"2:"						\
++			: [old] "=&r"(__oldval), [tmp] "=&r"(__tmp),	\
++			  [m] "=m"(*(mem))				\
++			: "m"(*(mem))					\
++			: "memory", "cc");				\
++		__oldval;						\
++	})
++
++#define atomic_exchange_acq(mem, newval)				\
++	({								\
++		if (sizeof(*(mem)) != 4)				\
++			abort();					\
++		__arch_exchange_32_acq(mem, newval);			\
++	})
++
++#define atomic_exchange_and_add(mem, newval)				\
++	({								\
++		if (sizeof(*(mem)) != 4)				\
++			abort();					\
++		__arch_atomic_exchange_and_add_32(mem, newval);		\
++	})
++
++#define atomic_decrement_if_positive(mem)				\
++	({								\
++		if (sizeof(*(mem)) != 4)				\
++			abort();					\
++		__arch_atomic_decrement_if_positive_32(mem);		\
++	})
++
++#endif /* _AVR32_BITS_ATOMIC_H */
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/bits/byteswap.h
+@@ -0,0 +1,70 @@
++/*
++ * Copyright (C) 2005 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++
++#if !defined _BYTESWAP_H && !defined _NETINET_IN_H
++# error "Never use <bits/byteswap.h> directly; include <byteswap.h> instead."
++#endif
++
++#ifndef _BITS_BYTESWAP_H
++#define _BITS_BYTESWAP_H 1
++
++/* Swap bytes in 16 bit value.  */
++#if defined __GNUC__
++# define __bswap_16(x) (__extension__ __builtin_bswap_16(x))
++#else
++/* This is better than nothing.  */
++static __inline unsigned short int
++__bswap_16 (unsigned short int __bsx)
++{
++	return ((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8));
++}
++#endif
++
++/* Swap bytes in 32 bit value.  */
++#if defined __GNUC__
++# define __bswap_32(x) (__extension__ __builtin_bswap_32(x))
++#else
++static __inline unsigned int
++__bswap_32 (unsigned int __bsx)
++{
++  return ((((__bsx) & 0xff000000) >> 24) | (((__bsx) & 0x00ff0000) >>  8) |
++	  (((__bsx) & 0x0000ff00) <<  8) | (((__bsx) & 0x000000ff) << 24));
++}
++#endif
++
++#if defined __GNUC__
++/* Swap bytes in 64 bit value.  */
++# define __bswap_constant_64(x)				\
++	((((x) & 0xff00000000000000ull) >> 56)		\
++	 | (((x) & 0x00ff000000000000ull) >> 40)	\
++	 | (((x) & 0x0000ff0000000000ull) >> 24)	\
++	 | (((x) & 0x000000ff00000000ull) >> 8)		\
++	 | (((x) & 0x00000000ff000000ull) << 8)		\
++	 | (((x) & 0x0000000000ff0000ull) << 24)	\
++	 | (((x) & 0x000000000000ff00ull) << 40)	\
++	 | (((x) & 0x00000000000000ffull) << 56))
++
++# define __bswap_64(x)							\
++	(__extension__							\
++	 ({								\
++		 union {						\
++			 __extension__ unsigned long long int __ll;	\
++			 unsigned int __l[2];				\
++		 } __w, __r;						\
++		 if (__builtin_constant_p(x))				\
++			 __r.__ll = __bswap_constant_64(x);		\
++		 else {							\
++			 __w.__ll = (x);				\
++			 __r.__l[0] = __bswap_32(__w.__l[1]);		\
++			 __r.__l[1] = __bswap_32(__w.__l[0]);		\
++		 }							\
++		 __r.__ll;						\
++	 }))
++#endif
++
++#endif /* _BITS_BYTESWAP_H */
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/bits/endian.h
+@@ -0,0 +1,7 @@
++/* AVR32 is big-endian */
++
++#ifndef _ENDIAN_H
++# error "Never use <bits/endian.h> directly; include <endian.h> instead."
++#endif
++
++#define __BYTE_ORDER __BIG_ENDIAN
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/bits/fcntl.h
+@@ -0,0 +1,165 @@
++#ifndef _FCNTL_H
++# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
++#endif
++
++#include <sys/types.h>
++
++/*
++ * open/fcntl - O_SYNC is only implemented on blocks devices and on files
++ * located on an ext2 file system
++ */
++#define O_ACCMODE	00000003
++#define O_RDONLY	00000000
++#define O_WRONLY	00000001
++#define O_RDWR		00000002
++#define O_CREAT		00000100	/* not fcntl */
++#define O_EXCL		00000200	/* not fcntl */
++#define O_NOCTTY	00000400	/* not fcntl */
++#define O_TRUNC		00001000	/* not fcntl */
++#define O_APPEND	00002000
++#define O_NONBLOCK	00004000
++#define O_NDELAY	O_NONBLOCK
++#define O_SYNC		00010000
++#define O_ASYNC		00020000
++
++#ifdef __USE_GNU
++# define O_DIRECT	00040000	/* must be a directory */
++# define O_DIRECTORY	00200000	/* direct disk access */
++# define O_NOFOLLOW	00400000	/* don't follow links */
++# define O_NOATIME	01000000	/* don't set atime */
++#endif
++
++#ifdef __USE_LARGEFILE64
++# define O_LARGEFILE	00100000
++#endif
++
++/* For now Linux has synchronisity options for data and read operations.
++   We define the symbols here but let them do the same as O_SYNC since
++   this is a superset.	*/
++#if defined __USE_POSIX199309 || defined __USE_UNIX98
++# define O_DSYNC	O_SYNC	/* Synchronize data.  */
++# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
++#endif
++
++#define F_DUPFD		0	/* dup */
++#define F_GETFD		1	/* get close_on_exec */
++#define F_SETFD		2	/* set/clear close_on_exec */
++#define F_GETFL		3	/* get file->f_flags */
++#define F_SETFL		4	/* set file->f_flags */
++
++#ifndef __USE_FILE_OFFSET64
++# define F_GETLK	5
++# define F_SETLK	6
++# define F_SETLKW	7
++#else
++# define F_GETLK	F_GETLK64
++# define F_SETLK	F_SETLK64
++# define F_SETLKW	F_SETLKW64
++#endif
++#define F_GETLK64	12	/*  using 'struct flock64' */
++#define F_SETLK64	13
++#define F_SETLKW64	14
++
++#if defined __USE_BSD || defined __USE_XOPEN2K
++# define F_SETOWN	8	/*  for sockets. */
++# define F_GETOWN	9	/*  for sockets. */
++#endif
++
++#ifdef __USE_GNU
++# define F_SETSIG	10	/*  for sockets. */
++# define F_GETSIG	11	/*  for sockets. */
++#endif
++
++#ifdef __USE_GNU
++# define F_SETLEASE	1024	/* Set a lease.	 */
++# define F_GETLEASE	1025	/* Enquire what lease is active.  */
++# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
++#endif
++
++/* for F_[GET|SET]FL */
++#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
++
++/* for posix fcntl() and lockf() */
++#define F_RDLCK		0
++#define F_WRLCK		1
++#define F_UNLCK		2
++
++/* for old implementation of bsd flock () */
++#define F_EXLCK		4	/* or 3 */
++#define F_SHLCK		8	/* or 4 */
++
++/* for leases */
++#define F_INPROGRESS	16
++
++#ifdef __USE_BSD
++/* operations for bsd flock(), also used by the kernel implementation */
++# define LOCK_SH	1	/* shared lock */
++# define LOCK_EX	2	/* exclusive lock */
++# define LOCK_NB	4	/* or'd with one of the above to prevent
++				   blocking */
++# define LOCK_UN	8	/* remove lock */
++#endif
++
++#ifdef __USE_GNU
++# define LOCK_MAND	32	/* This is a mandatory flock */
++# define LOCK_READ	64	/* ... Which allows concurrent
++				       read operations */
++# define LOCK_WRITE	128	/* ... Which allows concurrent
++				       write operations */
++# define LOCK_RW	192	/* ... Which allows concurrent
++				       read & write ops */
++#endif
++
++#ifdef __USE_GNU
++/* Types of directory notifications that may be requested with F_NOTIFY.  */
++# define DN_ACCESS	0x00000001	/* File accessed.  */
++# define DN_MODIFY	0x00000002	/* File modified.  */
++# define DN_CREATE	0x00000004	/* File created.  */
++# define DN_DELETE	0x00000008	/* File removed.  */
++# define DN_RENAME	0x00000010	/* File renamed.  */
++# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
++# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
++#endif
++
++struct flock {
++	short		l_type;
++	short		l_whence;
++#ifndef __USE_FILE_OFFSET64
++	__off_t		l_start;
++	__off_t		l_len;
++#else
++	__off64_t	l_start;
++	__off64_t	l_len;
++#endif
++	__pid_t		l_pid;
++};
++
++#ifdef __USE_LARGEFILE64
++struct flock64 {
++	short		l_type;
++	short		l_whence;
++	__off64_t	l_start;
++	__off64_t	l_len;
++	__pid_t		l_pid;
++};
++#endif
++
++/* Define some more compatibility macros to be backward compatible with
++ *    BSD systems which did not managed to hide these kernel macros.  */
++#ifdef  __USE_BSD
++# define FAPPEND        O_APPEND
++# define FFSYNC         O_FSYNC
++# define FASYNC         O_ASYNC
++# define FNONBLOCK      O_NONBLOCK
++# define FNDELAY        O_NDELAY
++#endif /* Use BSD.  */
++
++/* Advise to `posix_fadvise'.  */
++#ifdef __USE_XOPEN2K
++# define POSIX_FADV_NORMAL      0 /* No further special treatment.  */
++# define POSIX_FADV_RANDOM      1 /* Expect random page references.  */
++# define POSIX_FADV_SEQUENTIAL  2 /* Expect sequential page references.  */
++# define POSIX_FADV_WILLNEED    3 /* Will need these pages.  */
++# define POSIX_FADV_DONTNEED    4 /* Don't need these pages.  */
++# define POSIX_FADV_NOREUSE     5 /* Data will be accessed once.  */
++#endif
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/bits/kernel_stat.h
+@@ -0,0 +1,67 @@
++#ifndef _BITS_STAT_STRUCT_H
++#define _BITS_STAT_STRUCT_H
++
++#ifndef _LIBC
++#error bits/kernel_stat.h is for internal uClibc use only!
++#endif
++
++/*
++ * This file provides struct stat, taken from kernel 2.6.4. Verified
++ * to match kernel 2.6.22.
++ */
++
++struct kernel_stat {
++        unsigned long		st_dev;
++        unsigned long		st_ino;
++        unsigned short		st_mode;
++        unsigned short		st_nlink;
++        unsigned short		st_uid;
++        unsigned short		st_gid;
++        unsigned long		st_rdev;
++        unsigned long		st_size;
++        unsigned long		st_blksize;
++        unsigned long		st_blocks;
++        unsigned long		st_atime;
++        unsigned long		st_atime_nsec;
++        unsigned long		st_mtime;
++        unsigned long		st_mtime_nsec;
++        unsigned long		st_ctime;
++        unsigned long		st_ctime_nsec;
++        unsigned long		__unused4;
++        unsigned long		__unused5;
++};
++
++#define STAT_HAVE_NSEC 1
++
++struct kernel_stat64 {
++	unsigned long long	st_dev;
++
++	unsigned long long	st_ino;
++	unsigned int		st_mode;
++	unsigned int		st_nlink;
++
++	unsigned long		st_uid;
++	unsigned long		st_gid;
++
++	unsigned long long	st_rdev;
++
++	long long		st_size;
++	unsigned long		__pad1;
++	unsigned long		st_blksize;
++
++	unsigned long long	st_blocks;
++
++	unsigned long		st_atime;
++	unsigned long		st_atime_nsec;
++
++	unsigned long		st_mtime;
++	unsigned long		st_mtime_nsec;
++
++	unsigned long		st_ctime;
++	unsigned long		st_ctime_nsec;
++
++	unsigned long		__unused1;
++	unsigned long		__unused2;
++};
++
++#endif /* _BITS_STAT_STRUCT_H */
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/bits/kernel_types.h
+@@ -0,0 +1,55 @@
++/* Note that we use the exact same include guard #define names
++ * as asm/posix_types.h.  This will avoid gratuitous conflicts
++ * with the posix_types.h kernel header, and will ensure that
++ * our private content, and not the kernel header, will win.
++ *  -Erik
++ */
++#ifndef __ASM_AVR32_POSIX_TYPES_H
++#define __ASM_AVR32_POSIX_TYPES_H
++
++/*
++ * This file is generally used by user-level software, so you need to
++ * be a little careful about namespace pollution etc.  Also, we cannot
++ * assume GCC is being used.
++ */
++
++typedef unsigned long		__kernel_dev_t;
++typedef unsigned long		__kernel_ino_t;
++typedef unsigned short		__kernel_mode_t;
++typedef unsigned short		__kernel_nlink_t;
++typedef long			__kernel_off_t;
++typedef int			__kernel_pid_t;
++typedef unsigned short		__kernel_ipc_pid_t;
++typedef unsigned int		__kernel_uid_t;
++typedef unsigned int		__kernel_gid_t;
++typedef unsigned long		__kernel_size_t;
++typedef long			__kernel_ssize_t;
++typedef int			__kernel_ptrdiff_t;
++typedef long			__kernel_time_t;
++typedef long			__kernel_suseconds_t;
++typedef long			__kernel_clock_t;
++typedef int			__kernel_timer_t;
++typedef int			__kernel_clockid_t;
++typedef int			__kernel_daddr_t;
++typedef char *			__kernel_caddr_t;
++typedef unsigned short		__kernel_uid16_t;
++typedef unsigned short		__kernel_gid16_t;
++typedef unsigned int		__kernel_uid32_t;
++typedef unsigned int		__kernel_gid32_t;
++typedef unsigned short		__kernel_old_uid_t;
++typedef unsigned short		__kernel_old_gid_t;
++typedef unsigned short		__kernel_old_dev_t;
++
++#ifdef __GNUC__
++typedef long long		__kernel_loff_t;
++#endif
++
++typedef struct {
++#if defined(__USE_ALL)
++	int	val[2];
++#else
++	int	__val[2];
++#endif
++} __kernel_fsid_t;
++
++#endif /* __ASM_AVR32_POSIX_TYPES_H */
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/bits/mman.h
+@@ -0,0 +1,103 @@
++/* Definitions for POSIX memory map interface.  Linux/AVR32 version.
++   Copyright (C) 1997, 2000 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_MMAN_H
++# error "Never include this file directly.  Use <sys/mman.h> instead"
++#endif
++
++/* The following definitions basically come from the kernel headers.
++   But the kernel header is not namespace clean.  */
++
++
++/* Protections are chosen from these bits, OR'd together.  The
++   implementation does not necessarily support PROT_EXEC or PROT_WRITE
++   without PROT_READ.  The only guarantees are that no writing will be
++   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
++
++#define PROT_READ	0x1		/* Page can be read.  */
++#define PROT_WRITE	0x2		/* Page can be written.  */
++#define PROT_EXEC	0x4		/* Page can be executed.  */
++#define PROT_NONE	0x0		/* Page can not be accessed.  */
++#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
++					   growsdown vma (mprotect only).  */
++#define PROT_GROWSUP	0x02000000	/* Extend change to start of
++					   growsup vma (mprotect only).  */
++
++/* Sharing types (must choose one and only one of these).  */
++#define MAP_SHARED	0x01		/* Share changes.  */
++#define MAP_PRIVATE	0x02		/* Changes are private.  */
++#ifdef __USE_MISC
++# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
++#endif
++
++/* Other flags.  */
++#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
++#ifdef __USE_MISC
++# define MAP_FILE	0
++# define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
++# define MAP_ANON	MAP_ANONYMOUS
++#endif
++
++/* These are Linux-specific.  */
++#ifdef __USE_MISC
++# define MAP_GROWSDOWN	0x0100		/* Stack-like segment.  */
++# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
++# define MAP_EXECUTABLE	0x1000		/* Mark it as an executable.  */
++# define MAP_LOCKED	0x2000		/* Lock the mapping.  */
++# define MAP_NORESERVE	0x4000		/* Don't check for reservations.  */
++# define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
++# define MAP_NONBLOCK	0x10000		/* do not block on IO */
++#endif
++
++/* Flags to `msync'.  */
++#define MS_ASYNC	1		/* Sync memory asynchronously.  */
++#define MS_SYNC		4		/* Synchronous memory sync.  */
++#define MS_INVALIDATE	2		/* Invalidate the caches.  */
++
++/* Flags for `mlockall'.  */
++#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
++#define MCL_FUTURE	2		/* Lock all additions to address
++					   space.  */
++
++/* Flags for `mremap'.  */
++#ifdef __USE_GNU
++# define MREMAP_MAYMOVE	1
++# define MREMAP_FIXED	2
++#endif
++
++/* Advise to `madvise'.  */
++#ifdef __USE_BSD
++# define MADV_NORMAL	 0	/* No further special treatment.  */
++# define MADV_RANDOM	 1	/* Expect random page references.  */
++# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
++# define MADV_WILLNEED	 3	/* Will need these pages.  */
++# define MADV_DONTNEED	 4	/* Don't need these pages.  */
++# define MADV_REMOVE	 9	/* Remove these pages and resources.  */
++# define MADV_DONTFORK	 10	/* Do not inherit across fork.  */
++# define MADV_DOFORK	 11	/* Do inherit across fork.  */
++#endif
++
++/* The POSIX people had to invent similar names for the same things.  */
++#ifdef __USE_XOPEN2K
++# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
++# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
++# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
++# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
++# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
++#endif
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/bits/setjmp.h
+@@ -0,0 +1,30 @@
++/*
++ * Copyright (C) 2004-2005 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++#ifndef _BITS_SETJMP_H
++#define _BITS_SETJMP_H	1
++
++#if !defined _SETJMP_H && !defined _PTHREAD_H
++# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
++#endif
++
++#ifndef _ASM
++/*
++ * The jump buffer contains r0-r7, sr, sp and lr. Other registers are
++ * not saved.
++ */
++typedef int __jmp_buf[11];
++#endif
++
++#define __JMP_BUF_SP	4
++
++/* Test if longjmp to JMPBUF would unwind the frame containing a local
++   variable at ADDRESS.  */
++#define _JMPBUF_UNWINDS(jmpbuf, address) \
++  ((void *)(address) < (void *)(jmpbuf[__JMP_BUF_SP]))
++
++#endif /* _BITS_SETJMP_H */
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/bits/stackinfo.h
+@@ -0,0 +1,28 @@
++/* Copyright (C) 1999 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* This file contains a bit of information about the stack allocation
++   of the processor.  */
++
++#ifndef _STACKINFO_H
++#define _STACKINFO_H	1
++
++/* On AVR32 the stack grows down. */
++#define _STACK_GROWS_DOWN	1
++
++#endif	/* stackinfo.h */
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/bits/syscalls.h
+@@ -0,0 +1,143 @@
++#ifndef _BITS_SYSCALLS_H
++#define _BITS_SYSCALLS_H
++#ifndef _SYSCALL_H
++# error "Never use <bits/syscalls.h> directly; include <sys/syscall.h> instead."
++#endif
++
++/*
++ * This includes the `__NR_<name>' syscall numbers taken from the
++ * Linux kernel header files. It also defines the traditional
++ * `SYS_<name>' macros for older programs.
++ */
++#include <bits/sysnum.h>
++
++#ifndef __ASSEMBLER__
++
++#include <errno.h>
++
++#define SYS_ify(syscall_name) (__NR_##syscall_name)
++
++#undef _syscall0
++#define _syscall0(type,name)				\
++	type name(void)					\
++	{						\
++		return (type)(INLINE_SYSCALL(name, 0));	\
++	}
++
++#undef _syscall1
++#define _syscall1(type,name,type1,arg1)				\
++	type name(type1 arg1)					\
++	{							\
++		return (type)(INLINE_SYSCALL(name, 1, arg1));	\
++	}
++
++#undef _syscall2
++#define _syscall2(type,name,type1,arg1,type2,arg2)			\
++	type name(type1 arg1, type2 arg2)				\
++	{								\
++		return (type)(INLINE_SYSCALL(name, 2, arg1, arg2));	\
++	}
++
++#undef _syscall3
++#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3)		\
++	type name(type1 arg1, type2 arg2, type3 arg3)			\
++	{								\
++		return (type)(INLINE_SYSCALL(name, 3, arg1,		\
++					     arg2, arg3));		\
++	}
++
++#undef _syscall4
++#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,		\
++		  type4,arg4)						\
++	type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4)	\
++	{								\
++		return (type)(INLINE_SYSCALL(name, 4, arg1, arg2,	\
++					     arg3, arg4));		\
++	}
++
++#undef _syscall5
++#define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,		\
++		  type4,arg4,type5,arg5)				\
++	type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4,	\
++		  type5 arg5)						\
++	{								\
++		return (type)(INLINE_SYSCALL(name, 5, arg1, arg2,	\
++					     arg3, arg4, arg5));	\
++	}
++
++#undef _syscall6
++#define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,		\
++		  type4,arg4,type5,arg5,type6,arg6)			\
++	type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4,	\
++		  type5 arg5, type6 arg6)				\
++	{								\
++		return (type)(INLINE_SYSCALL(name, 6, arg1, arg2, arg3,	\
++					     arg4, arg5, arg6));	\
++	}
++
++#undef unlikely
++#define unlikely(x) __builtin_expect((x), 0)
++
++#undef INLINE_SYSCALL
++#define INLINE_SYSCALL(name, nr, args...)				\
++	({								\
++		unsigned _sys_result = INTERNAL_SYSCALL(name, , nr, args); \
++		if (unlikely(INTERNAL_SYSCALL_ERROR_P(_sys_result, ))) { \
++			__set_errno(INTERNAL_SYSCALL_ERRNO(_sys_result, )); \
++			_sys_result = (unsigned int) -1;		\
++		}							\
++		(int) _sys_result;					\
++	})
++
++#undef INTERNAL_SYSCALL_DECL
++#define INTERNAL_SYSCALL_DECL(err) do { } while(0)
++
++#undef INTERNAL_SYSCALL
++#define INTERNAL_SYSCALL(name, err, nr, args...)			\
++	({								\
++		register int _a1 asm ("r12");				\
++		register int _scno asm("r8") = SYS_ify(name);		\
++		LOAD_ARGS_##nr (args);					\
++		asm volatile ("scall	/* syscall " #name " */"	\
++			      : "=r" (_a1)				\
++			      : "r"(_scno) ASM_ARGS_##nr		\
++			      : "cc", "memory");			\
++		_a1;							\
++	})
++
++#undef INTERNAL_SYSCALL_ERROR_P
++#define INTERNAL_SYSCALL_ERROR_P(val, err)		\
++	((unsigned int)(val) >= 0xfffff001U)
++
++#undef INTERNAL_SYSCALL_ERRNO
++#define INTERNAL_SYSCALL_ERRNO(val, errr) (-(val))
++
++#define LOAD_ARGS_0() do { } while(0)
++#define ASM_ARGS_0
++#define LOAD_ARGS_1(a1)					\
++	_a1 = (int) (a1);				\
++	LOAD_ARGS_0()
++#define ASM_ARGS_1	ASM_ARGS_0, "r"(_a1)
++#define LOAD_ARGS_2(a1, a2)				\
++	register int _a2 asm("r11") = (int)(a2);	\
++	LOAD_ARGS_1(a1)
++#define ASM_ARGS_2	ASM_ARGS_1, "r"(_a2)
++#define LOAD_ARGS_3(a1, a2, a3)				\
++	register int _a3 asm("r10") = (int)(a3);	\
++	LOAD_ARGS_2(a1, a2)
++#define ASM_ARGS_3	ASM_ARGS_2, "r"(_a3)
++#define LOAD_ARGS_4(a1, a2, a3, a4)			\
++	register int _a4 asm("r9") = (int)(a4);		\
++	LOAD_ARGS_3(a1, a2, a3)
++#define ASM_ARGS_4	ASM_ARGS_3, "r"(_a4)
++#define LOAD_ARGS_5(a1, a2, a3, a4, a5)			\
++	register int _a5 asm("r5") = (int)(a5);		\
++	LOAD_ARGS_4(a1, a2, a3, a4)
++#define ASM_ARGS_5	ASM_ARGS_4, "r"(_a5)
++#define LOAD_ARGS_6(a1, a2, a3, a4, a5, a6)		\
++	register int _a6 asm("r3") = (int)(a6);		\
++	LOAD_ARGS_5(a1, a2, a3, a4, a5)
++#define ASM_ARGS_6	ASM_ARGS_5, "r"(_a6)
++
++#endif /* __ASSEMBLER__ */
++#endif /* _BITS_SYSCALLS_H */
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/bits/uClibc_arch_features.h
+@@ -0,0 +1,45 @@
++/*
++ * Track misc arch-specific features that aren't config options
++ */
++
++#ifndef _BITS_UCLIBC_ARCH_FEATURES_H
++#define _BITS_UCLIBC_ARCH_FEATURES_H
++
++/* instruction used when calling abort() to kill yourself */
++/* trigger illegal instruction exception, same as BUG in Linux */
++#define __UCLIBC_ABORT_INSTRUCTION__ ".short 0x5df0"
++
++/* can your target use syscall6() for mmap ? */
++#define __UCLIBC_MMAP_HAS_6_ARGS__
++
++/* does your target use syscall4() for truncate64 ? (32bit arches only) */
++#undef __UCLIBC_TRUNCATE64_HAS_4_ARGS__
++
++/* does your target have a broken create_module() ? */
++#undef __UCLIBC_BROKEN_CREATE_MODULE__
++
++/* does your target have to worry about older [gs]etrlimit() ? */
++#undef __UCLIBC_HANDLE_OLDER_RLIMIT__
++
++/* does your target prefix all symbols with an _ ? */
++#define __UCLIBC_NO_UNDERSCORES__
++
++/* does your target have an asm .set ? */
++#define __UCLIBC_HAVE_ASM_SET_DIRECTIVE__
++
++/* define if target doesn't like .global */
++#undef __UCLIBC_ASM_GLOBAL_DIRECTIVE__
++
++/* define if target supports .weak */
++#define __UCLIBC_HAVE_ASM_WEAK_DIRECTIVE__
++
++/* define if target supports .weakext */
++#undef __UCLIBC_HAVE_ASM_WEAKEXT_DIRECTIVE__
++
++/* needed probably only for ppc64 */
++#undef __UCLIBC_HAVE_ASM_GLOBAL_DOT_NAME__
++
++/* define if target supports IEEE signed zero floats */
++#define __UCLIBC_HAVE_SIGNED_ZERO__
++
++#endif /* _BITS_UCLIBC_ARCH_FEATURES_H */
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/bits/wordsize.h
+@@ -0,0 +1 @@
++#define __WORDSIZE	32
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/brk.c
+@@ -0,0 +1,31 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++#include <errno.h>
++#include <unistd.h>
++#include <sys/syscall.h>
++
++libc_hidden_proto(brk)
++
++void *__curbrk attribute_hidden = 0;
++
++int brk (void *addr)
++{
++	void *newbrk;
++
++	newbrk = (void *)INLINE_SYSCALL(brk, 1, addr);
++
++	__curbrk = newbrk;
++
++	if (newbrk < addr) {
++		__set_errno (ENOMEM);
++		return -1;
++	}
++
++	return 0;
++}
++libc_hidden_def(brk)
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/bsd-_setjmp.S
+@@ -0,0 +1,16 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++
++	/* This just does a tail-call to __sigsetjmp(env, 0) */
++	.global	_setjmp
++	.type	_setjmp,"function"
++	.align	1
++_setjmp:
++	mov	r11, 0
++	bral	__GI___sigsetjmp
++	.size	_setjmp, . - _setjmp
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/bsd-setjmp.S
+@@ -0,0 +1,16 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++
++	/* This just does a tail-call to __sigsetjmp(env, 1) */
++	.global	setjmp
++	.type	setjmp,"function"
++	.align	1
++setjmp:
++	mov	r11, 1
++	bral	__GI___sigsetjmp
++	.size	setjmp, . - setjmp
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/clone.c
+@@ -0,0 +1,41 @@
++/*
++ * Copyright (C) 2004 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++#include <errno.h>
++#include <sys/syscall.h>
++#include <unistd.h>
++
++/*
++ * I don't know if we can be absolutely certain that the fn and arg
++ * parameters are preserved when returning as the child. If the
++ * compiler stores them in registers (r0-r7), they should be.
++ */
++int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg)
++{
++	register int (*_fn)(void *arg) = fn;
++	register void *_arg = arg;
++	int err;
++
++	/* Sanity check the arguments */
++	err = -EINVAL;
++	if (!fn)
++		goto syscall_error;
++	if (!child_stack)
++		goto syscall_error;
++
++	err = INLINE_SYSCALL(clone, 2, flags, child_stack);
++	if (err < 0)
++		goto syscall_error;
++	else if (err != 0)
++		return err;
++
++	_exit(_fn(_arg));
++
++syscall_error:
++	__set_errno (-err);
++	return -1;
++}
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/crt1.S
+@@ -0,0 +1,97 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ *
++ * When we enter _start, the stack looks like this:
++ *	argc		argument counter
++ *	argv[0]		pointer to program name
++ *	argv[1..argc-1]	pointers to program args
++ *	NULL
++ *	env[0..N]	pointers to environment variables
++ *	NULL
++ *
++ * r12 contains a function pointer to be registered with `atexit'.
++ * This is how the dynamic linker arranges to have DT_FINI functions
++ * called for shared libraries that have been loaded before this
++ * code runs.
++ *
++ * We're going to call the following function:
++ * __uClibc_main(int (*main)(int, char **, char **), int argc,
++ *		 char **argv, void (*app_init)(void), void (*app_fini)(void),
++ *		 void (*rtld_fini)(void), void *stack_end)
++ *
++ * So we need to set up things as follows:
++ *	r12 = address of main
++ *	r11 = argc
++ *	r10 = &argv[0]
++ *	r9  = address of _init
++ *	r8  = address of _fini
++ *	sp[0] = whatever we got passed in r12
++ */
++
++#include <features.h>
++
++	.text
++	.global _start
++	.type	_start, @function
++_start:
++	/* Clear the frame pointer and link register since this is the outermost frame.  */
++	mov	r7, 0
++	mov	lr, 0
++
++	ld.w	r11, sp++		/* argc		*/
++	mov	r10, sp			/* &argv[0]	*/
++
++	st.w	--sp, r10		/* stack_end */
++	st.w	--sp, r12		/* rtld_fini */
++
++#ifdef __PIC__
++	lddpc	r6, .L_GOT
++.L_RGOT:
++	rsub	r6, pc
++	lda.w	r9, _init
++	lda.w	r8, _fini
++	lda.w	r12, main
++
++	/* Ok, now run uClibc's main() -- should not return */
++	call	__uClibc_main
++
++	.align	2
++.L_GOT:
++	.long	.L_RGOT - _GLOBAL_OFFSET_TABLE_
++#else
++	lddpc	r9, __init_addr		/* app_init */
++	lddpc	r8, __fini_addr		/* app_fini */
++	lddpc	r12, __main_addr	/* main */
++
++	/* Ok, now run uClibc's main() -- should not return */
++	lddpc	pc, ___uClibc_main_addr
++
++	.align	2
++__init_addr:
++	.long	_init
++__fini_addr:
++	.long	_fini
++__main_addr:
++	.long	main
++___uClibc_main_addr:
++	.long	__uClibc_main
++#endif
++	.size	_start, . - _start
++
++	/*
++	 * The LSB says we need this.
++	 */
++	.section ".note.ABI-tag", "a"
++	.align	4
++	.long	2f - 1f		/* namesz */
++	.long	4f - 3f		/* descsz */
++	.long	1		/* type   */
++1:	.asciz	"GNU"		/* name */
++2:	.align	4
++3:	.long	0		/* Linux executable */
++	.long	2,6,0		/* Earliest compatible kernel */
++4:	.align	4
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/crti.S
+@@ -0,0 +1,26 @@
++
++	.section .init
++	.align	2
++	.global	_init
++	.type	_init, @function
++_init:
++	stm	--sp, r6, lr
++	lddpc	r6, 2f
++1:	rsub	r6, pc
++	rjmp	3f
++	.align	2
++2:	.long	1b - _GLOBAL_OFFSET_TABLE_
++3:
++
++	.section .fini
++	.align	2
++	.global	_fini
++	.type	_fini, @function
++_fini:
++	stm	--sp, r6, lr
++	lddpc	r6, 2f
++1:	rsub	r6, pc
++	rjmp	3f
++	.align	2
++2:	.long	1b - _GLOBAL_OFFSET_TABLE_
++3:
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/crtn.S
+@@ -0,0 +1,14 @@
++
++	.section .init
++	.align	2
++	.global	_init
++	.type	_init, @function
++	ldm	sp++, r6, pc
++	.size	_init, . - _init
++
++	.section .fini
++	.align	2
++	.global _fini
++	.type	_fini, @function
++	ldm	sp++, r6, pc
++	.size	_fini, . - _fini
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/mmap.c
+@@ -0,0 +1,33 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++
++#include <errno.h>
++#include <unistd.h>
++#include <sys/mman.h>
++#include <sys/syscall.h>
++
++libc_hidden_proto(mmap)
++
++static _syscall6(__ptr_t, mmap2, __ptr_t, addr, size_t, len, int, prot,
++		 int, flags, int, fd, __off_t, pgoff);
++
++__ptr_t mmap(__ptr_t addr, size_t len, int prot, int flags, int fd, __off_t offset)
++{
++	unsigned long page_size = sysconf(_SC_PAGESIZE);
++	unsigned long pgoff;
++
++	if (offset & (page_size - 1)) {
++		__set_errno(EINVAL);
++		return MAP_FAILED;
++	}
++
++	pgoff = (unsigned long)offset >> (31 - __builtin_clz(page_size));
++
++	return mmap2(addr, len, prot, flags, fd, pgoff);
++}
++libc_hidden_def(mmap)
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/setjmp.S
+@@ -0,0 +1,29 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++#define _SETJMP_H
++#define _ASM
++#include <bits/setjmp.h>
++
++	.text
++
++	.global	__sigsetjmp
++	.type	__sigsetjmp,"function"
++
++	.align	1
++__sigsetjmp:
++	mustr	r8
++	stm	r12, r0,r1,r2,r3,r4,r5,r6,r7,r8,sp,lr
++
++	/*
++	 * Make a tail call to __sigjmp_save; it takes the same args
++	 * and is hidden so we don't need to mess around with the GOT.
++	 */
++	rjmp	__sigjmp_save
++	.size	__sigsetjmp, . - __sigsetjmp
++
++libc_hidden_def(__sigsetjmp)
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/sigaction.c
+@@ -0,0 +1,59 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++#include <errno.h>
++#include <signal.h>
++#include <string.h>
++#include <sys/syscall.h>
++#include <bits/kernel_sigaction.h>
++
++#define SA_RESTORER	0x04000000
++extern void __default_rt_sa_restorer(void);
++
++libc_hidden_proto(memcpy)
++
++/*
++ * If act is not NULL, change the action for sig to *act.
++ * If oact is not NULL, put the old action for sig in *oact.
++ */
++int __libc_sigaction(int signum, const struct sigaction *act,
++		     struct sigaction *oldact)
++{
++	struct kernel_sigaction kact, koact;
++	int result;
++
++	if (act) {
++		kact.k_sa_handler = act->sa_handler;
++		memcpy(&kact.sa_mask, &act->sa_mask, sizeof (kact.sa_mask));
++		kact.sa_flags = act->sa_flags;
++		if (kact.sa_flags & (SA_RESTORER | SA_ONSTACK))
++			kact.sa_restorer = act->sa_restorer;
++		else
++			kact.sa_restorer = __default_rt_sa_restorer;
++		kact.sa_flags |= SA_RESTORER;
++	}
++
++	result = __syscall_rt_sigaction(signum, act ? __ptrvalue(&kact) : NULL,
++					oldact ? __ptrvalue(&koact) : NULL,
++					_NSIG / 8);
++
++	if (oldact && result >= 0) {
++		oldact->sa_handler = koact.k_sa_handler;
++		memcpy(&oldact->sa_mask, &koact.sa_mask,
++		       sizeof(oldact->sa_mask));
++		oldact->sa_flags = koact.sa_flags;
++		oldact->sa_restorer = koact.sa_restorer;
++	}
++
++	return result;
++}
++
++#ifndef LIBC_SIGACTION
++libc_hidden_proto(sigaction)
++weak_alias(__libc_sigaction, sigaction)
++libc_hidden_weak(sigaction)
++#endif
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/sigrestorer.S
+@@ -0,0 +1,15 @@
++/*
++ * Copyright (C) 2004 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++#include <sys/syscall.h>
++
++	.global	__default_rt_sa_restorer
++	.type	__default_rt_sa_restorer,"function"
++	.align	1
++__default_rt_sa_restorer:
++	mov	r8, __NR_rt_sigreturn
++	scall
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/sys/elf.h
+@@ -0,0 +1,26 @@
++/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_ELF_H
++#define _SYS_ELF_H	1
++
++#warning "This header is obsolete; use <sys/procfs.h> instead."
++
++#include <sys/procfs.h>
++
++#endif	/* sys/elf.h */
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/sys/procfs.h
+@@ -0,0 +1,123 @@
++/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_PROCFS_H
++#define _SYS_PROCFS_H	1
++
++/* This is somewhat modelled after the file of the same name on SVR4
++   systems.  It provides a definition of the core file format for ELF
++   used on Linux.  It doesn't have anything to do with the /proc file
++   system, even though Linux has one.
++
++   Anyway, the whole purpose of this file is for GDB and GDB only.
++   Don't read too much into it.  Don't use it for anything other than
++   GDB unless you know what you are doing.  */
++
++#include <features.h>
++#include <sys/time.h>
++#include <sys/types.h>
++#include <sys/user.h>
++
++__BEGIN_DECLS
++
++/* Type for a general-purpose register.  */
++typedef unsigned long elf_greg_t;
++
++/* And the whole bunch of them.  We could have used `struct
++   user_regs' directly in the typedef, but tradition says that
++   the register set is an array, which does have some peculiar
++   semantics, so leave it that way.  */
++#define ELF_NGREG (sizeof (struct user_regs) / sizeof(elf_greg_t))
++typedef elf_greg_t elf_gregset_t[ELF_NGREG];
++
++/* Register set for the floating-point registers.  */
++typedef struct user_fpregs elf_fpregset_t;
++
++/* Signal info.  */
++struct elf_siginfo
++  {
++    int si_signo;			/* Signal number.  */
++    int si_code;			/* Extra code.  */
++    int si_errno;			/* Errno.  */
++  };
++
++/* Definitions to generate Intel SVR4-like core files.  These mostly
++   have the same names as the SVR4 types with "elf_" tacked on the
++   front to prevent clashes with Linux definitions, and the typedef
++   forms have been avoided.  This is mostly like the SVR4 structure,
++   but more Linuxy, with things that Linux does not support and which
++   GDB doesn't really use excluded.  */
++
++struct elf_prstatus
++  {
++    struct elf_siginfo pr_info;		/* Info associated with signal.  */
++    short int pr_cursig;		/* Current signal.  */
++    unsigned long int pr_sigpend;	/* Set of pending signals.  */
++    unsigned long int pr_sighold;	/* Set of held signals.  */
++    __pid_t pr_pid;
++    __pid_t pr_ppid;
++    __pid_t pr_pgrp;
++    __pid_t pr_sid;
++    struct timeval pr_utime;		/* User time.  */
++    struct timeval pr_stime;		/* System time.  */
++    struct timeval pr_cutime;		/* Cumulative user time.  */
++    struct timeval pr_cstime;		/* Cumulative system time.  */
++    elf_gregset_t pr_reg;		/* GP registers.  */
++    int pr_fpvalid;			/* True if math copro being used.  */
++  };
++
++
++#define ELF_PRARGSZ     (80)    /* Number of chars for args.  */
++
++struct elf_prpsinfo
++  {
++    char pr_state;			/* Numeric process state.  */
++    char pr_sname;			/* Char for pr_state.  */
++    char pr_zomb;			/* Zombie.  */
++    char pr_nice;			/* Nice val.  */
++    unsigned long int pr_flag;		/* Flags.  */
++    unsigned short int pr_uid;
++    unsigned short int pr_gid;
++    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
++    /* Lots missing */
++    char pr_fname[16];			/* Filename of executable.  */
++    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
++  };
++
++/* The rest of this file provides the types for emulation of the
++   Solaris <proc_service.h> interfaces that should be implemented by
++   users of libthread_db.  */
++
++/* Addresses.  */
++typedef void *psaddr_t;
++
++/* Register sets.  Linux has different names.  */
++typedef elf_gregset_t prgregset_t;
++typedef elf_fpregset_t prfpregset_t;
++
++/* We don't have any differences between processes and threads,
++   therefore have only one PID type.  */
++typedef __pid_t lwpid_t;
++
++/* Process status and info.  In the end we do provide typedefs for them.  */
++typedef struct elf_prstatus prstatus_t;
++typedef struct elf_prpsinfo prpsinfo_t;
++
++__END_DECLS
++
++#endif	/* sys/procfs.h */
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/sys/ucontext.h
+@@ -0,0 +1,90 @@
++/* Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* Linux/AVR32 ABI compliant context switching support.  */
++
++#ifndef _SYS_UCONTEXT_H
++#define _SYS_UCONTEXT_H	1
++
++#include <features.h>
++#include <signal.h>
++#include <sys/procfs.h>
++#include <bits/sigcontext.h>
++
++typedef int greg_t;
++
++/* Number of general registers.  */
++#define NGREG	16
++
++/* Container for all general registers.  */
++typedef elf_gregset_t gregset_t;
++
++/* Number of each register is the `gregset_t' array.  */
++enum
++{
++  R0 = 0,
++#define R0	R0
++  R1 = 1,
++#define R1	R1
++  R2 = 2,
++#define R2	R2
++  R3 = 3,
++#define R3	R3
++  R4 = 4,
++#define R4	R4
++  R5 = 5,
++#define R5	R5
++  R6 = 6,
++#define R6	R6
++  R7 = 7,
++#define R7	R7
++  R8 = 8,
++#define R8	R8
++  R9 = 9,
++#define R9	R9
++  R10 = 10,
++#define R10	R10
++  R11 = 11,
++#define R11	R11
++  R12 = 12,
++#define R12	R12
++  R13 = 13,
++#define R13	R13
++  R14 = 14,
++#define R14	R14
++  R15 = 15
++#define R15	R15
++};
++
++/* Structure to describe FPU registers.  */
++typedef elf_fpregset_t	fpregset_t;
++
++/* Context to describe whole processor state.  */
++typedef struct sigcontext mcontext_t;
++
++/* Userlevel context.  */
++typedef struct ucontext
++{
++	unsigned long	uc_flags;
++	struct ucontext	*uc_link;
++	stack_t		uc_stack;
++	mcontext_t	uc_mcontext;
++	sigset_t	uc_sigmask;   /* mask last for extensibility */
++} ucontext_t;
++
++#endif /* sys/ucontext.h */
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/sys/user.h
+@@ -0,0 +1,46 @@
++#ifndef _SYS_USER_H
++#define _SYS_USER_H
++
++struct user_fpregs
++{
++
++};
++
++struct user_regs
++{
++	unsigned long sr;
++	unsigned long pc;
++	unsigned long lr;
++	unsigned long sp;
++	unsigned long r12;
++	unsigned long r11;
++	unsigned long r10;
++	unsigned long r9;
++	unsigned long r8;
++	unsigned long r7;
++	unsigned long r6;
++	unsigned long r5;
++	unsigned long r4;
++	unsigned long r3;
++	unsigned long r2;
++	unsigned long r1;
++	unsigned long r0;
++	unsigned long r12_orig;
++};
++
++struct user
++{
++	struct user_regs	regs;		/* general registers */
++	size_t			u_tsize;	/* text size (pages) */
++	size_t			u_dsize;	/* data size (pages) */
++	size_t			u_ssize;	/* stack size (pages) */
++	unsigned long		start_code;	/* text starting address */
++	unsigned long		start_data;	/* data starting address */
++	unsigned long		start_stack;	/* stack starting address */
++	long int		signal;		/* signal causing core dump */
++	struct user_regs *	u_ar0;		/* help gdb find registers */
++	unsigned long		magic;		/* identifies a core file */
++	char			u_comm[32];	/* user command name */
++};
++
++#endif /* _SYS_USER_H */
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/syscall.S
+@@ -0,0 +1,71 @@
++/*
++ * Copyright (C) 2004-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++#include <features.h>
++
++	.text
++
++	/*
++	 * long int syscall(long int sysno, ...)
++	 */
++	.global	syscall
++	.type	syscall, @function
++	.align	2
++syscall:
++	stm	--sp, r3,r5,r6,lr
++	sub	lr, sp, -16
++	mov	r8, r12
++	ldm	lr, r3,r5,r9-r12
++	scall
++	cp.w	r12, -4095
++	brlo	.Ldone
++
++#ifdef __PIC__
++	lddpc	r6, .Lgot
++.Lgotcalc:
++	rsub	r6, pc
++# ifdef __UCLIBC_HAS_THREADS__
++	rsub	r3, r12, 0
++	mcall	r6[__errno_location@got]
++	st.w	r12[0], r3
++# else
++	ld.w	r3, r6[errno@got]
++	neg	r12
++	st.w	r3[0], r12
++# endif
++#else
++# ifdef __UCLIBC_HAS_THREADS__
++	rsub	r3, r12, 0
++	mcall	.Lerrno_location
++	st.w	r12[0], r3
++# else
++	lddpc	r3, .Lerrno
++	neg	r12
++	st.w	r3[0], r12
++# endif
++#endif
++	mov	r12, -1
++
++.Ldone:
++	ldm	sp++, r3,r5,r6,pc
++
++	.align	2
++#ifdef __PIC__
++.Lgot:
++	.long	.Lgotcalc - _GLOBAL_OFFSET_TABLE_
++#else
++# ifdef __UCLIBC_HAS_THREADS__
++.Lerrno_location:
++	.long	__errno_location
++# else
++.Lerrno:
++	.long	errno
++# endif
++#endif
++
++
++	.size	syscall, . - syscall
+--- /dev/null
++++ b/libc/sysdeps/linux/avr32/vfork.S
+@@ -0,0 +1,58 @@
++/*
++ * Copyright (C) 2005 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++
++/*
++ * Clone the process without copying the address space.  The
++ * calling process is suspended until the child either exits
++ * or calls execve.
++ *
++ * This all means that we cannot rely on the stack to store
++ * away registers, since they will be overwritten by the child
++ * as soon as it makes another function call (e.g. execve()).
++ * Fortunately, the Linux kernel preserves LR across system calls.
++ */
++
++#include <features.h>
++#include <sys/syscall.h>
++
++	.global	__vfork
++	.type	__vfork,@function
++	.align	1
++__vfork:
++	mov	r8, __NR_vfork
++	scall
++	cp.w	r12, -4096
++	retls	r12
++
++	/* vfork failed, so we may use the stack freely */
++	pushm	r4-r7,lr
++#ifdef __PIC__
++	lddpc	r6, .L_GOT
++	rsub	r4, r12, 0
++.L_RGOT:
++	rsub	r6, pc
++	mcall	r6[__errno_location@got]
++#else
++	rsub	r4, r12, 0
++	mcall	.L__errno_location
++#endif
++	st.w	r12[0], r4
++	popm	r4-r7,pc,r12=-1
++
++	.align	2
++#ifdef __PIC__
++.L_GOT:
++	.long	.L_RGOT - _GLOBAL_OFFSET_TABLE_
++#else
++.L__errno_location:
++	.long	__errno_location
++#endif
++	.size	__vfork, . - __vfork
++
++weak_alias(__vfork,vfork)
++libc_hidden_weak(vfork)
+--- /dev/null
++++ b/libpthread/linuxthreads.old/sysdeps/avr32/pt-machine.h
+@@ -0,0 +1,73 @@
++/* Machine-dependent pthreads configuration and inline functions.
++ *
++ * Copyright (C) 2005-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++#ifndef _PT_MACHINE_H
++#define _PT_MACHINE_H   1
++
++#include <features.h>
++
++static inline int
++_test_and_set (int *p, int v)
++{
++	int result;
++
++	__asm__ __volatile__(
++		"/* Inline test and set */\n"
++		"	xchg	%[old], %[mem], %[new]"
++		: [old] "=&r"(result)
++		: [mem] "r"(p), [new] "r"(v)
++		: "memory");
++
++	return result;
++}
++
++#ifndef PT_EI
++# define PT_EI extern inline
++#endif
++
++extern long int testandset (int *spinlock);
++extern int __compare_and_swap (long int *p, long int oldval, long int newval);
++
++/* Spinlock implementation; required.  */
++PT_EI long int
++testandset (int *spinlock)
++{
++	return _test_and_set(spinlock, 1);
++}
++
++
++/* Get some notion of the current stack.  Need not be exactly the top
++   of the stack, just something somewhere in the current frame.  */
++#define CURRENT_STACK_FRAME  stack_pointer
++register char * stack_pointer __asm__ ("sp");
++
++/* Compare-and-swap for semaphores. */
++
++#define HAS_COMPARE_AND_SWAP
++PT_EI int
++__compare_and_swap(long int *p, long int oldval, long int newval)
++{
++	long int result;
++
++	__asm__ __volatile__(
++		"/* Inline compare and swap */\n"
++		"1:	ssrf	5\n"
++		"	ld.w	%[result], %[mem]\n"
++		"	eor	%[result], %[old]\n"
++		"	brne	2f\n"
++		"	stcond	%[mem], %[new]\n"
++		"	brne	1b\n"
++		"2:"
++		: [result] "=&r"(result), [mem] "=m"(*p)
++		: "m"(*p), [new] "r"(newval), [old] "r"(oldval)
++		: "cc", "memory");
++
++	return result == 0;
++}
++
++#endif /* pt-machine.h */
+--- /dev/null
++++ b/libpthread/linuxthreads/sysdeps/avr32/pt-machine.h
+@@ -0,0 +1,73 @@
++/* Machine-dependent pthreads configuration and inline functions.
++ *
++ * Copyright (C) 2005-2007 Atmel Corporation
++ *
++ * This file is subject to the terms and conditions of the GNU Lesser General
++ * Public License.  See the file "COPYING.LIB" in the main directory of this
++ * archive for more details.
++ */
++#ifndef _PT_MACHINE_H
++#define _PT_MACHINE_H   1
++
++#include <features.h>
++
++static inline int
++_test_and_set (int *p, int v) __THROW
++{
++	int result;
++
++	__asm__ __volatile__(
++		"/* Inline test and set */\n"
++		"	xchg	%[old], %[mem], %[new]"
++		: [old] "=&r"(result)
++		: [mem] "r"(p), [new] "r"(v)
++		: "memory");
++
++	return result;
++}
++
++#ifndef PT_EI
++# define PT_EI extern inline
++#endif
++
++extern long int testandset (int *spinlock);
++extern int __compare_and_swap (long int *p, long int oldval, long int newval);
++
++/* Spinlock implementation; required.  */
++PT_EI long int
++testandset (int *spinlock)
++{
++	return _test_and_set(spinlock, 1);
++}
++
++
++/* Get some notion of the current stack.  Need not be exactly the top
++   of the stack, just something somewhere in the current frame.  */
++#define CURRENT_STACK_FRAME  stack_pointer
++register char * stack_pointer __asm__ ("sp");
++
++/* Compare-and-swap for semaphores. */
++
++#define HAS_COMPARE_AND_SWAP
++PT_EI int
++__compare_and_swap(long int *p, long int oldval, long int newval)
++{
++	int result;
++
++	__asm__ __volatile__(
++		"/* Inline compare and swap */\n"
++		"1:	ssrf	5\n"
++		"	ld.w	%[result], %[mem]\n"
++		"	eor	%[result], %[old]\n"
++		"	brne	2f\n"
++		"	stcond	%[mem], %[new]\n"
++		"	brne	1b\n"
++		"2:"
++		: [result] "=&r"(result), [mem] "=m"(*p)
++		: "m"(*p), [new] "r"(newval), [old] "r"(oldval)
++		: "cc", "memory");
++
++	return result == 0;
++}
++
++#endif /* pt-machine.h */
+--- a/utils/ldd.c
++++ b/utils/ldd.c
+@@ -44,6 +44,11 @@
+ #define ELFCLASSM	ELFCLASS32
+ #endif
+ 
++#if defined(__avr32__)
++#define MATCH_MACHINE(x) (x == EM_AVR32)
++#define ELFCLASSM	ELFCLASS32
++#endif
++
+ #if defined(__s390__)
+ #define MATCH_MACHINE(x) (x == EM_S390)
+ #define ELFCLASSM	ELFCLASS32
diff --git a./toolchain/uClibc/patches-0.9.29/008-avr32_fix_sa_onstack.patch b./toolchain/uClibc/patches-0.9.29/008-avr32_fix_sa_onstack.patch
new file mode 100644
index 0000000..5a30861
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/008-avr32_fix_sa_onstack.patch
@@ -0,0 +1,26 @@
+From 974a769cc135bcfb1ea751db34a84ed6b5ceb509 Mon Sep 17 00:00:00 2001
+From: Haavard Skinnemoen <hskinnemoen@atmel.com>
+Date: Fri, 7 Dec 2007 14:02:19 +0100
+Subject: [PATCH] AVR32: Fix sa_restorer when SA_ONSTACK is set
+
+I don't remember exactly why we decided to pick the caller's value of
+sa_restorer when SA_ONSTACK is set, but it seems to break LTP's
+sigaltstack testcase. Some users have reported problems with
+sigaltstack as well; hopefully this will fix it.
+
+Signed-off-by: Haavard Skinnemoen <hskinnemoen@atmel.com>
+---
+ libc/sysdeps/linux/avr32/sigaction.c |    2 +-
+ 1 files changed, 1 insertions(+), 1 deletions(-)
+
+--- a/libc/sysdeps/linux/avr32/sigaction.c
++++ b/libc/sysdeps/linux/avr32/sigaction.c
+@@ -30,7 +30,7 @@ int __libc_sigaction(int signum, const s
+ 		kact.k_sa_handler = act->sa_handler;
+ 		memcpy(&kact.sa_mask, &act->sa_mask, sizeof (kact.sa_mask));
+ 		kact.sa_flags = act->sa_flags;
+-		if (kact.sa_flags & (SA_RESTORER | SA_ONSTACK))
++		if (kact.sa_flags & SA_RESTORER)
+ 			kact.sa_restorer = act->sa_restorer;
+ 		else
+ 			kact.sa_restorer = __default_rt_sa_restorer;
diff --git a./toolchain/uClibc/patches-0.9.29/009-fix_getaddrinfo_infinite_loop.patch b./toolchain/uClibc/patches-0.9.29/009-fix_getaddrinfo_infinite_loop.patch
new file mode 100644
index 0000000..5d702a3
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/009-fix_getaddrinfo_infinite_loop.patch
@@ -0,0 +1,13 @@
+--- a/libc/inet/getaddrinfo.c
++++ b/libc/inet/getaddrinfo.c
+@@ -858,7 +858,10 @@ getaddrinfo (const char *name, const cha
+ 	if (hints->ai_family == g->family || hints->ai_family == AF_UNSPEC)
+ 	{
+ 	    if ((hints->ai_flags & AI_ADDRCONFIG) && !addrconfig(g->family))
++	    {
++		g++;
+ 		continue;
++	    }
+ 	    j++;
+ 	    if (pg == NULL || pg->gaih != g->gaih)
+ 	    {
diff --git a./toolchain/uClibc/patches-0.9.29/100-termios.patch b./toolchain/uClibc/patches-0.9.29/100-termios.patch
new file mode 100644
index 0000000..413c124
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/100-termios.patch
@@ -0,0 +1,20 @@
+--- a/libc/sysdeps/linux/common/bits/termios.h
++++ b/libc/sysdeps/linux/common/bits/termios.h
+@@ -156,7 +156,6 @@ struct termios
+ #endif
+ #define  B57600   0010001
+ #define  B115200  0010002
+-#if 0 /* limited on uClibc, keep in sync w/ cfsetspeed.c */
+ #define  B230400  0010003
+ #define  B460800  0010004
+ #define  B500000  0010005
+@@ -171,9 +170,6 @@ struct termios
+ #define  B3500000 0010016
+ #define  B4000000 0010017
+ #define __MAX_BAUD B4000000
+-#else
+-#define __MAX_BAUD B115200
+-#endif
+ #ifdef __USE_MISC
+ # define CIBAUD	  002003600000		/* input baud rate (not used) */
+ # define CMSPAR   010000000000		/* mark or space (stick) parity */
diff --git a./toolchain/uClibc/patches-0.9.29/110-compat_macros.patch b./toolchain/uClibc/patches-0.9.29/110-compat_macros.patch
new file mode 100644
index 0000000..032de41
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/110-compat_macros.patch
@@ -0,0 +1,95 @@
+--- a/include/string.h
++++ b/include/string.h
+@@ -320,18 +320,40 @@ extern char *index (__const char *__s, i
+ /* Find the last occurrence of C in S (same as strrchr).  */
+ extern char *rindex (__const char *__s, int __c)
+      __THROW __attribute_pure__ __nonnull ((1));
+-# else
+-#  ifdef __UCLIBC_SUSV3_LEGACY_MACROS__
++# elif defined(__UCLIBC_SUSV3_LEGACY_MACROS__) && !defined(_STRINGS_H)
+ /* bcopy/bzero/bcmp/index/rindex are marked LEGACY in SuSv3.
+  * They are replaced as proposed by SuSv3. Don't sync this part
+  * with glibc and keep it in sync with strings.h.  */
+ 
+-#  define bcopy(src,dest,n) (memmove((dest), (src), (n)), (void) 0)
+-#  define bzero(s,n) (memset((s), '\0', (n)), (void) 0)
+-#  define bcmp(s1,s2,n) memcmp((s1), (s2), (size_t)(n))
+-#  define index(s,c) strchr((s), (c))
+-#  define rindex(s,c) strrchr((s), (c))
+-#  endif
++/* Copy N bytes of SRC to DEST (like memmove, but args reversed).  */
++static __inline__ void bcopy (__const void *__src, void *__dest, size_t __n)
++{
++	memmove(__dest, __src, __n);
++}
++
++/* Set N bytes of S to 0.  */
++static __inline__ void bzero (void *__s, size_t __n)
++{
++	memset(__s, 0, __n);
++}
++
++/* Compare N bytes of S1 and S2 (same as memcmp).  */
++static __inline__ int bcmp (__const void *__s1, __const void *__s2, size_t __n)
++{
++	return memcmp(__s1, __s2, __n);
++}
++
++/* Find the first occurrence of C in S (same as strchr).  */
++static __inline__ char *index (__const char *__s, int __c)
++{
++	return strchr(__s, __c);
++}
++
++/* Find the last occurrence of C in S (same as strrchr).  */
++static __inline__ char *rindex (__const char *__s, int __c)
++{
++	return strrchr(__s, __c);
++}
+ # endif
+ 
+ /* Return the position of the first bit set in I, or 0 if none are set.
+--- a/include/strings.h
++++ b/include/strings.h
+@@ -58,11 +58,36 @@ extern char *rindex (__const char *__s, 
+  * They are replaced as proposed by SuSv3. Don't sync this part
+  * with glibc and keep it in sync with string.h.  */
+ 
+-#  define bcopy(src,dest,n) (memmove((dest), (src), (n)), (void) 0)
+-#  define bzero(s,n) (memset((s), '\0', (n)), (void) 0)
+-#  define bcmp(s1,s2,n) memcmp((s1), (s2), (size_t)(n))
+-#  define index(s,c) strchr((s), (c))
+-#  define rindex(s,c) strrchr((s), (c))
++
++/* Copy N bytes of SRC to DEST (like memmove, but args reversed).  */
++static __inline__ void bcopy (__const void *__src, void *__dest, size_t __n)
++{
++	memmove(__dest, __src, __n);
++}
++
++/* Set N bytes of S to 0.  */
++static __inline__ void bzero (void *__s, size_t __n)
++{
++	memset(__s, 0, __n);
++}
++
++/* Compare N bytes of S1 and S2 (same as memcmp).  */
++static __inline__ int bcmp (__const void *__s1, __const void *__s2, size_t __n)
++{
++	return memcmp(__s1, __s2, __n);
++}
++
++/* Find the first occurrence of C in S (same as strchr).  */
++static __inline__ char *index (__const char *__s, int __c)
++{
++	return strchr(__s, __c);
++}
++
++/* Find the last occurrence of C in S (same as strrchr).  */
++static __inline__ char *rindex (__const char *__s, int __c)
++{
++	return strrchr(__s, __c);
++}
+ #  endif
+ # endif
+ 
diff --git a./toolchain/uClibc/patches-0.9.29/120-adjtimex.patch b./toolchain/uClibc/patches-0.9.29/120-adjtimex.patch
new file mode 100644
index 0000000..3813607
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/120-adjtimex.patch
@@ -0,0 +1,12 @@
+--- a/include/sys/timex.h
++++ b/include/sys/timex.h
+@@ -116,7 +116,8 @@ struct timex
+ 
+ __BEGIN_DECLS
+ 
+-extern int __adjtimex (struct timex *__ntx) __THROW;
++#undef __adjtimex
++#define __adjtimex adjtimex
+ extern int adjtimex (struct timex *__ntx) __THROW;
+ 
+ extern int ntp_gettime (struct ntptimeval *__ntv) __THROW;
diff --git a./toolchain/uClibc/patches-0.9.29/130-compile_fixes.patch b./toolchain/uClibc/patches-0.9.29/130-compile_fixes.patch
new file mode 100644
index 0000000..8a61291
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/130-compile_fixes.patch
@@ -0,0 +1,22 @@
+--- a/libc/string/mips/sysdep.h
++++ b/libc/string/mips/sysdep.h
+@@ -29,7 +29,7 @@
+   .globl name;                                                                \
+   .align 2;                                                                   \
+   .ent name,0;                                                                \
+-  name##:
++  name:
+ 
+ #undef END
+ #define END(function)                                   \
+--- a/Rules.mak
++++ b/Rules.mak
+@@ -399,7 +399,7 @@ ifneq ($(HAVE_SHARED),y)
+ CFLAGS += -DSTATIC
+ endif
+ 
+-CFLAGS += $(call check_gcc,-std=gnu99,)
++# CFLAGS += $(call check_gcc,-std=gnu99,)
+ 
+ LDFLAGS_NOSTRIP:=$(CPU_LDFLAGS-y) -shared --warn-common --warn-once -z combreloc
+ # binutils-2.16.1 warns about ignored sections, 2.16.91.0.3 and newer are ok
diff --git a./toolchain/uClibc/patches-0.9.29/130-sockets_throw.patch b./toolchain/uClibc/patches-0.9.29/130-sockets_throw.patch
new file mode 100644
index 0000000..7735b60
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/130-sockets_throw.patch
@@ -0,0 +1,11 @@
+--- a/libc/sysdeps/linux/mips/bits/socket.h
++++ b/libc/sysdeps/linux/mips/bits/socket.h
+@@ -269,7 +269,7 @@ struct cmsghdr
+ #define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
+ 
+ extern struct cmsghdr * __NTH (__cmsg_nxthdr (struct msghdr *__mhdr,
+-				      struct cmsghdr *__cmsg)) __THROW;
++				      struct cmsghdr *__cmsg));
+ #ifdef __USE_EXTERN_INLINES
+ # ifndef _EXTERN_INLINE
+ #  define _EXTERN_INLINE extern __inline
diff --git a./toolchain/uClibc/patches-0.9.29/131-arm_ftruncate64.patch b./toolchain/uClibc/patches-0.9.29/131-arm_ftruncate64.patch
new file mode 100644
index 0000000..5b23421
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/131-arm_ftruncate64.patch
@@ -0,0 +1,11 @@
+--- a/libc/sysdeps/linux/arm/bits/uClibc_arch_features.h
++++ b/libc/sysdeps/linux/arm/bits/uClibc_arch_features.h
+@@ -38,4 +38,8 @@
+ /* define if target supports IEEE signed zero floats */
+ #define __UCLIBC_HAVE_SIGNED_ZERO__
+ 
++#ifdef __ARM_EABI__
++# define __UCLIBC_TRUNCATE64_HAS_4_ARGS__
++#endif
++
+ #endif /* _BITS_UCLIBC_ARCH_FEATURES_H */
diff --git a./toolchain/uClibc/patches-0.9.29/132-arm_fix_alignment.patch b./toolchain/uClibc/patches-0.9.29/132-arm_fix_alignment.patch
new file mode 100644
index 0000000..acf3654
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/132-arm_fix_alignment.patch
@@ -0,0 +1,11 @@
+--- a/ldso/ldso/arm/dl-sysdep.h
++++ b/ldso/ldso/arm/dl-sysdep.h
+@@ -15,6 +15,8 @@
+   GOT_BASE[1] = (unsigned long) MODULE; \
+ }
+ 
++#define DL_MALLOC_ALIGN 8 /* EABI needs 8 byte alignment for STRD LDRD*/
++
+ static inline unsigned long arm_modulus(unsigned long m, unsigned long p)
+ {
+ 	unsigned long i,t,inc;
diff --git a./toolchain/uClibc/patches-0.9.29/133-unistd_arm.patch b./toolchain/uClibc/patches-0.9.29/133-unistd_arm.patch
new file mode 100644
index 0000000..a152888
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/133-unistd_arm.patch
@@ -0,0 +1,28 @@
+--- a/extra/scripts/gen_bits_syscall_h.sh
++++ b/extra/scripts/gen_bits_syscall_h.sh
+@@ -24,8 +24,8 @@ esac
+ ( echo "#include <asm/unistd.h>";
+   echo "#include <asm/unistd.h>" |
+   $CC -E $CC_SYSNUM_ARGS $INCLUDE_OPTS - |
+-  sed -ne 's/^[ ]*#define[ ]*__NR_\([A-Za-z0-9_]*\).*/UCLIBC_\1 __NR_\1/gp' \
+-      -e 's/^[ ]*#undef[ ]*__NR_\([A-Za-z0-9_]*\).*/UNDEFUCLIBC_\1 __NR_\1/gp' # needed to strip out any kernel-internal defines
++  sed -ne 's/^[ ]*#define[ ]*\(__ARM_NR_\|__NR_\)\([A-Za-z0-9_]*\).*/UCLIBC\1\2 \1\2/gp' \
++      -e 's/^[ ]*#undef[ ]*\(__ARM_NR_\|__NR_\)\([A-Za-z0-9_]*\).*/UNDEFUCLIBC\1\2 \1\2/gp' # needed to strip out any kernel-internal defines
+ ) |
+ $CC -E $INCLUDE_OPTS - |
+ ( echo "/* WARNING!!! AUTO-GENERATED FILE!!! DO NOT EDIT!!! */" ; echo ;
+@@ -35,10 +35,10 @@ $CC -E $INCLUDE_OPTS - |
+   echo "#ifndef _SYSCALL_H" ;
+   echo "# error \"Never use <bits/sysnum.h> directly; include <sys/syscall.h> instead.\"" ;
+   echo "#endif" ; echo ;
+-  sed -ne 's/^UCLIBC_\([A-Za-z0-9_]*\) *\(.*\)/#undef __NR_\1\
+-#define __NR_\1 \2\
+-#define SYS_\1 __NR_\1/gp' \
+-     -e 's/^UNDEFUCLIBC_\([A-Za-z0-9_]*\).*/#undef __NR_\1/gp'
++  sed -ne 's/^UCLIBC\(__ARM_NR_\|__NR_\)\([A-Za-z0-9_]*\) *\(.*\)/#undef \1\2\
++#define \1\2 \3\
++#define SYS_\2 \1\2/gp' \
++     -e 's/^UNDEFUCLIBC\(__ARM_NR_\|__NR_\)\([A-Za-z0-9_]*\).*/#undef \1\2/gp'
+   echo ;
+   echo "#endif" ;
+ )
diff --git a./toolchain/uClibc/patches-0.9.29/140-fix-endless-recursion-in-pthread.patch b./toolchain/uClibc/patches-0.9.29/140-fix-endless-recursion-in-pthread.patch
new file mode 100644
index 0000000..c967e1b
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/140-fix-endless-recursion-in-pthread.patch
@@ -0,0 +1,13 @@
+--- a/libpthread/linuxthreads.old/pthread.c
++++ b/libpthread/linuxthreads.old/pthread.c
+@@ -335,9 +335,9 @@ struct pthread_functions __pthread_funct
+     .ptr_pthread_raise = pthread_raise,
+     .ptr__pthread_cleanup_push = _pthread_cleanup_push,
+     .ptr__pthread_cleanup_pop = _pthread_cleanup_pop
+-*/
+     .ptr__pthread_cleanup_push_defer = _pthread_cleanup_push_defer,
+     .ptr__pthread_cleanup_pop_restore = _pthread_cleanup_pop_restore,
++*/
+   };
+ #ifdef SHARED
+ # define ptr_pthread_functions &__pthread_functions
diff --git a./toolchain/uClibc/patches-0.9.29/150-fix-ldso-text-realloc-segfault.patch b./toolchain/uClibc/patches-0.9.29/150-fix-ldso-text-realloc-segfault.patch
new file mode 100644
index 0000000..7006f98
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/150-fix-ldso-text-realloc-segfault.patch
@@ -0,0 +1,29 @@
+--- a/ldso/ldso/ldso.c
++++ b/ldso/ldso/ldso.c
+@@ -286,15 +286,20 @@ void _dl_get_ready_to_run(struct elf_res
+ 			_dl_debug_early("calling mprotect on the application program\n");
+ 			/* Now cover the application program. */
+ 			if (app_tpnt->dynamic_info[DT_TEXTREL]) {
+-				ppnt = (ElfW(Phdr) *) auxvt[AT_PHDR].a_un.a_val;
+-				for (i = 0; i < auxvt[AT_PHNUM].a_un.a_val; i++, ppnt++) {
+-					if (ppnt->p_type == PT_LOAD && !(ppnt->p_flags & PF_W))
+-						_dl_mprotect((void *) (DL_RELOC_ADDR(app_tpnt->loadaddr, ppnt->p_vaddr) & PAGE_ALIGN),
+-							     ((ppnt->p_vaddr + app_tpnt->loadaddr) & ADDR_ALIGN) +
+-							     (unsigned long) ppnt->p_filesz,
++				ElfW(Phdr) *ppnt_inner = (ElfW(Phdr) *) auxvt[AT_PHDR].a_un.a_val;
++				for (i = 0; i < auxvt[AT_PHNUM].a_un.a_val; i++, ppnt_inner++) {
++					if (ppnt_inner->p_type == PT_LOAD && !(ppnt_inner->p_flags & PF_W))
++						_dl_mprotect((void *) (DL_RELOC_ADDR(app_tpnt->loadaddr, ppnt_inner->p_vaddr) & PAGE_ALIGN),
++							     ((ppnt_inner->p_vaddr + app_tpnt->loadaddr) & ADDR_ALIGN) +
++							     (unsigned long) ppnt_inner->p_filesz,
+ 							     PROT_READ | PROT_WRITE | PROT_EXEC);
+ 				}
+ 			}
++#else
++			if (app_tpnt->dynamic_info[DT_TEXTREL]) {
++				_dl_dprintf(_dl_debug_file, "Can't modify application's text section; use the GCC option -fPIE for position-independent executables.\n");
++				_dl_exit(1);
++}
+ #endif
+ 
+ #ifndef ALLOW_ZERO_PLTGOT
diff --git a./toolchain/uClibc/patches-0.9.29/160-mips_syscall.patch b./toolchain/uClibc/patches-0.9.29/160-mips_syscall.patch
new file mode 100644
index 0000000..c5e5f6b
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/160-mips_syscall.patch
@@ -0,0 +1,31 @@
+--- uClibc-0.9.29.orig/libc/sysdeps/linux/mips/syscall.S	2009-02-27 19:26:57.420288905 +0100
++++ uClibc-0.9.29/libc/sysdeps/linux/mips/syscall.S	2009-02-27 19:43:18.000000000 +0100
+@@ -29,6 +29,9 @@
+ .type   syscall,@function
+ .ent    syscall
+ syscall:
++#ifdef __PIC__
++	SETUP_GP
++#endif
+ 	move	v0, a0		/* Load system call number from first arg.  */
+ 	move	a0, a1		/* Move the next three args up a register.  */
+ 	move	a1, a2
+@@ -60,6 +63,18 @@
+ #else
+ 	addiu	sp,sp,32
+ #endif
++	bnez	a3, 1f
+      	j ra			/* Return to caller.  */
++1:
++	move	a0,v0		/* Pass return val to C function. */
++
++#ifdef __PIC__
++	SETUP_GP64(v0, syscall)
++	PTR_LA	t9, __syscall_error
++	RESTORE_GP64
++	jr	t9
++#else
++	j	__syscall_error
++#endif
+ .end    syscall
+ .size   syscall,.-syscall
diff --git a./toolchain/uClibc/patches-0.9.29/170-enable-getifaddrs.patch b./toolchain/uClibc/patches-0.9.29/170-enable-getifaddrs.patch
new file mode 100644
index 0000000..5b0d4fc
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/170-enable-getifaddrs.patch
@@ -0,0 +1,155 @@
+--- a/libc/inet/ifaddrs.c
++++ b/libc/inet/ifaddrs.c
+@@ -38,6 +38,7 @@
+ #include <unistd.h>
+ 
+ #include "netlinkaccess.h"
++#include "ifaddrs.h"
+ 
+ libc_hidden_proto(socket)
+ libc_hidden_proto(close)
+@@ -57,7 +58,6 @@ libc_hidden_proto(abort)
+ 
+ 
+ #if __ASSUME_NETLINK_SUPPORT
+-#if 0 /* unused code */
+ /* struct to hold the data for one ifaddrs entry, so we can allocate
+    everything at once.  */
+ struct ifaddrs_storage
+@@ -74,8 +74,6 @@ struct ifaddrs_storage
+   } addr, netmask, broadaddr;
+   char name[IF_NAMESIZE + 1];
+ };
+-#endif /* unused code */
+-
+ 
+ void
+ __netlink_free_handle (struct netlink_handle *h)
+@@ -323,8 +321,6 @@ __netlink_open (struct netlink_handle *h
+   return 0;
+ }
+ 
+-
+-#if 0 /* unused code */
+ /* We know the number of RTM_NEWLINK entries, so we reserve the first
+    # of entries for this type. All RTM_NEWADDR entries have an index
+    pointer to the RTM_NEWLINK entry.  To find the entry, create
+@@ -562,7 +558,7 @@ getifaddrs (struct ifaddrs **ifap)
+ 		      if ((rta_payload + 1) <= sizeof (ifas[ifa_index].name))
+ 			{
+ 			  ifas[ifa_index].ifa.ifa_name = ifas[ifa_index].name;
+-			  *(char *) __mempcpy (ifas[ifa_index].name, rta_data,
++			  *(char *) mempcpy (ifas[ifa_index].name, rta_data,
+ 					       rta_payload) = '\0';
+ 			}
+ 		      break;
+@@ -761,7 +757,7 @@ getifaddrs (struct ifaddrs **ifap)
+ 		      if (rta_payload + 1 <= sizeof (ifas[ifa_index].name))
+ 			{
+ 			  ifas[ifa_index].ifa.ifa_name = ifas[ifa_index].name;
+-			  *(char *) __mempcpy (ifas[ifa_index].name, rta_data,
++			  *(char *) mempcpy (ifas[ifa_index].name, rta_data,
+ 					       rta_payload) = '\0';
+ 			}
+ 		      else
+@@ -872,6 +868,4 @@ freeifaddrs (struct ifaddrs *ifa)
+ }
+ #endif
+ 
+-#endif /* unused code */
+-
+ #endif /* __ASSUME_NETLINK_SUPPORT */
+--- a/libc/inet/netlinkaccess.h
++++ b/libc/inet/netlinkaccess.h
+@@ -61,14 +61,11 @@ struct netlink_handle
+ };
+ 
+ 
+-#if 0 /* unused code */
+ #if __ASSUME_NETLINK_SUPPORT == 0
+ extern int __no_netlink_support attribute_hidden;
+ #else
+ # define __no_netlink_support 0
+ #endif
+-#endif /* unused code */
+-
+ 
+ extern int __netlink_open (struct netlink_handle *h) attribute_hidden;
+ extern void __netlink_close (struct netlink_handle *h) attribute_hidden;
+--- /dev/null
++++ b/include/ifaddrs.h
+@@ -0,0 +1,74 @@
++/* ifaddrs.h -- declarations for getting network interface addresses
++   Copyright (C) 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _IFADDRS_H
++#define _IFADDRS_H	1
++
++#include <features.h>
++#include <sys/socket.h>
++
++__BEGIN_DECLS
++
++/* The `getifaddrs' function generates a linked list of these structures.
++   Each element of the list describes one network interface.  */
++struct ifaddrs
++{
++  struct ifaddrs *ifa_next;	/* Pointer to the next structure.  */
++
++  char *ifa_name;		/* Name of this network interface.  */
++  unsigned int ifa_flags;	/* Flags as from SIOCGIFFLAGS ioctl.  */
++
++  struct sockaddr *ifa_addr;	/* Network address of this interface.  */
++  struct sockaddr *ifa_netmask; /* Netmask of this interface.  */
++  union
++  {
++    /* At most one of the following two is valid.  If the IFF_BROADCAST
++       bit is set in `ifa_flags', then `ifa_broadaddr' is valid.  If the
++       IFF_POINTOPOINT bit is set, then `ifa_dstaddr' is valid.
++       It is never the case that both these bits are set at once.  */
++    struct sockaddr *ifu_broadaddr; /* Broadcast address of this interface. */
++    struct sockaddr *ifu_dstaddr; /* Point-to-point destination address.  */
++  } ifa_ifu;
++  /* These very same macros are defined by <net/if.h> for `struct ifaddr'.
++     So if they are defined already, the existing definitions will be fine.  */
++# ifndef ifa_broadaddr
++#  define ifa_broadaddr	ifa_ifu.ifu_broadaddr
++# endif
++# ifndef ifa_dstaddr
++#  define ifa_dstaddr	ifa_ifu.ifu_dstaddr
++# endif
++
++  void *ifa_data;		/* Address-specific data (may be unused).  */
++};
++
++
++/* Create a linked list of `struct ifaddrs' structures, one for each
++   network interface on the host machine.  If successful, store the
++   list in *IFAP and return 0.  On errors, return -1 and set `errno'.
++
++   The storage returned in *IFAP is allocated dynamically and can
++   only be properly freed by passing it to `freeifaddrs'.  */
++extern int getifaddrs (struct ifaddrs **__ifap) __THROW;
++
++/* Reclaim the storage allocated by a previous `getifaddrs' call.  */
++extern void freeifaddrs (struct ifaddrs *__ifa)  __THROW;
++
++__END_DECLS
++
++#endif /* ifaddrs.h */
diff --git a./toolchain/uClibc/patches-0.9.29/180-fix_kernel_types_with_recent_kernel.patch b./toolchain/uClibc/patches-0.9.29/180-fix_kernel_types_with_recent_kernel.patch
new file mode 100644
index 0000000..24ed697
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/180-fix_kernel_types_with_recent_kernel.patch
@@ -0,0 +1,21 @@
+This patch is out of uClibc trunk.
+
+--- a/libc/sysdeps/linux/i386/bits/kernel_types.h
++++ b/libc/sysdeps/linux/i386/bits/kernel_types.h
+@@ -7,10 +7,14 @@
+ 
+ /* a hack for compiling a 32 bit user space with 64 bit
+  * kernel on x86_64  */
+-#if !defined(__ARCH_I386_POSIX_TYPES_H) && !defined(_ASM_X86_64_POSIX_TYPES_H)
++#if !defined(__ARCH_I386_POSIX_TYPES_H) && \
++    !defined(_ASM_X86_64_POSIX_TYPES_H) && \
++    !defined(_ASM_X86_POSIX_TYPES_32_H) && \
++    !defined(_ASM_X86_POSIX_TYPES_64_H)
+ #define _ASM_X86_64_POSIX_TYPES_H
+ #define __ARCH_I386_POSIX_TYPES_H
+-
++#define _ASM_X86_POSIX_TYPES_32_H
++#define _ASM_X86_POSIX_TYPES_64_H
+ typedef unsigned short	__kernel_dev_t;
+ typedef unsigned long	__kernel_ino_t;
+ typedef unsigned short	__kernel_mode_t;
diff --git a./toolchain/uClibc/patches-0.9.29/190-install_tls.patch b./toolchain/uClibc/patches-0.9.29/190-install_tls.patch
new file mode 100644
index 0000000..74d4032
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/190-install_tls.patch
@@ -0,0 +1,12 @@
+--- a/libpthread/linuxthreads/Makefile.in
++++ b/libpthread/linuxthreads/Makefile.in
+@@ -128,7 +128,9 @@ linuxthreads_headers:
+ 	$(Q)$(LN) -sf ../$(PTDIR)/sysdeps/pthread/pthread.h $(top_builddir)include/
+ 	$(Q)$(LN) -sf ../$(PTDIR)/semaphore.h $(top_builddir)include/
+ 	$(Q)$(INSTALL) -d $(top_builddir)include/bits
++	$(Q)$(INSTALL) -d $(top_builddir)include/sys
+ 	$(Q)$(LN) -sf ../../$(PTDIR)/sysdeps/pthread/bits/pthreadtypes.h $(top_builddir)include/bits/
++	$(Q)$(LN) -sf ../../$(PTDIR)/sysdeps/$(TARGET_ARCH)/tls.h $(top_builddir)include/sys/
+ 
+ linuxthreads_headers_clean:
+ 	$(RM) $(top_builddir)include/pthread.h $(top_builddir)include/semaphore.h \
diff --git a./toolchain/uClibc/patches-0.9.29/200-libpthread_fix.patch b./toolchain/uClibc/patches-0.9.29/200-libpthread_fix.patch
new file mode 100644
index 0000000..148f608
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/200-libpthread_fix.patch
@@ -0,0 +1,56 @@
+--- a/libpthread/linuxthreads/libc-cancellation.c
++++ b/libpthread/linuxthreads/libc-cancellation.c
+@@ -31,9 +31,6 @@
+ weak_extern (__pthread_do_exit)
+ # endif
+ 
+-int __libc_multiple_threads attribute_hidden __attribute__((nocommon));
+-strong_alias (__libc_multiple_threads, __librt_multiple_threads)
+-
+ /* The next two functions are similar to pthread_setcanceltype() but
+    more specialized for the use in the cancelable functions like write().
+    They do not need to check parameters etc.  */
+--- a/libpthread/linuxthreads/libc_pthread_init.c
++++ b/libpthread/linuxthreads/libc_pthread_init.c
+@@ -33,6 +33,9 @@ libc_hidden_proto(memcpy)
+ libc_hidden_proto(uselocale)
+ #endif
+ 
++int __libc_multiple_threads attribute_hidden __attribute__((nocommon));
++strong_alias (__libc_multiple_threads, __librt_multiple_threads)
++
+ int *
+ __libc_pthread_init (functions)
+      const struct pthread_functions *functions;
+--- a/libpthread/linuxthreads/Makefile.in
++++ b/libpthread/linuxthreads/Makefile.in
+@@ -77,7 +77,7 @@ libpthread-a-y  += $(libpthread_OBJ:.o=.
+ else
+ libpthread-a-y  += $(libpthread_OBJ) $(libpthread-static-y)
+ endif
+-libpthread-so-y += $(libpthread_OBJ:.o=.os)
++libpthread-so-y += $(libpthread_OBJ:.o=.oS)
+ 
+ lib-a-$(UCLIBC_HAS_THREADS) += $(top_builddir)lib/libpthread.a
+ lib-so-$(UCLIBC_HAS_THREADS) += $(top_builddir)lib/libpthread.so
+--- a/libpthread/linuxthreads/pthread.c
++++ b/libpthread/linuxthreads/pthread.c
+@@ -32,6 +32,8 @@
+ #include "smp.h"
+ #include <not-cancel.h>
+ 
++#define HAVE_Z_NODELETE
++
+ /* Sanity check.  */
+ #if !defined __SIGRTMIN || (__SIGRTMAX - __SIGRTMIN) < 3
+ # error "This must not happen"
+@@ -976,7 +978,9 @@ static void pthread_onexit_process(int r
+     request.req_args.exit.code = retcode;
+     TEMP_FAILURE_RETRY(write_not_cancel(__pthread_manager_request,
+ 					(char *) &request, sizeof(request)));
++#ifdef notyet
+     suspend(self);
++#endif
+     /* Main thread should accumulate times for thread manager and its
+        children, so that timings for main thread account for all threads. */
+     if (self == __pthread_main_thread)
diff --git a./toolchain/uClibc/patches-0.9.29/210-trunc.patch b./toolchain/uClibc/patches-0.9.29/210-trunc.patch
new file mode 100644
index 0000000..18417fb
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/210-trunc.patch
@@ -0,0 +1,21 @@
+--- a/libm/s_floor.c
++++ b/libm/s_floor.c
+@@ -81,3 +81,18 @@ libm_hidden_proto(floor)
+ 	return x;
+ }
+ libm_hidden_def(floor)
++
++
++libm_hidden_proto(trunc)
++double
++trunc(double x)
++{
++	if (!finite (x))
++		return x;
++
++	if (x < 0.0)
++		return - floor (-x);
++	else
++		return floor (x);
++}
++libm_hidden_def(trunc)
diff --git a./toolchain/uClibc/patches-0.9.29/220-libpthread_sysdep_fixes.patch b./toolchain/uClibc/patches-0.9.29/220-libpthread_sysdep_fixes.patch
new file mode 100644
index 0000000..bb76dc1
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/220-libpthread_sysdep_fixes.patch
@@ -0,0 +1,37 @@
+--- /dev/null
++++ b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/arm/sysdep-cancel.h
+@@ -0,0 +1,24 @@
++/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Guido Guenther <agx@sigxcpu.org>, 2003.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
++
++# define SINGLE_THREAD_P (1)
++
++#endif
+--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/mips/sysdep-cancel.h
++++ b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/mips/sysdep-cancel.h
+@@ -17,7 +17,6 @@
+    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA.  */
+ 
+-#include <sysdep.h>
+ #ifndef __ASSEMBLER__
+ # include <linuxthreads/internals.h>
+ #endif
diff --git a./toolchain/uClibc/patches-0.9.29/230-pthread_weak_binding.patch b./toolchain/uClibc/patches-0.9.29/230-pthread_weak_binding.patch
new file mode 100644
index 0000000..92227cf
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/230-pthread_weak_binding.patch
@@ -0,0 +1,10 @@
+--- a/libc/unistd/daemon.c
++++ b/libc/unistd/daemon.c
+@@ -54,7 +54,6 @@
+ libc_hidden_proto(dup2)
+ libc_hidden_proto(setsid)
+ libc_hidden_proto(chdir)
+-libc_hidden_proto(fork)
+ 
+ int daemon( int nochdir, int noclose )
+ {
diff --git a./toolchain/uClibc/patches-0.9.29/240-math_call.patch b./toolchain/uClibc/patches-0.9.29/240-math_call.patch
new file mode 100644
index 0000000..a69fe4e
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/240-math_call.patch
@@ -0,0 +1,29 @@
+--- a/libc/sysdeps/linux/common/bits/mathcalls.h
++++ b/libc/sysdeps/linux/common/bits/mathcalls.h
+@@ -190,20 +190,20 @@
+ 
+ /* Return 0 if VALUE is finite or NaN, +1 if it
+    is +Infinity, -1 if it is -Infinity.  */
+-__MATHDECL_1 (int,__isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));
++__MATHDECL_1 (int,isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));
+ 
+ /* Return nonzero if VALUE is finite and not NaN.  */
+-__MATHDECL_1 (int,__finite,, (_Mdouble_ __value)) __attribute__ ((__const__));
+-_Mdouble_END_NAMESPACE
++__MATHDECL_1 (int,finite,, (_Mdouble_ __value)) __attribute__ ((__const__));
+ 
+-#ifdef __USE_MISC
+ /* Return 0 if VALUE is finite or NaN, +1 if it
+    is +Infinity, -1 if it is -Infinity.  */
+-__MATHDECL_1 (int,isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));
++__MATHDECL_1 (int,__isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));
+ 
+ /* Return nonzero if VALUE is finite and not NaN.  */
+-__MATHDECL_1 (int,finite,, (_Mdouble_ __value)) __attribute__ ((__const__));
++__MATHDECL_1 (int,__finite,, (_Mdouble_ __value)) __attribute__ ((__const__));
++_Mdouble_END_NAMESPACE
+ 
++#ifdef __USE_MISC
+ /* Return the remainder of X/Y.  */
+ __MATHCALL (drem,, (_Mdouble_ __x, _Mdouble_ __y));
+ 
diff --git a./toolchain/uClibc/patches-0.9.29/300-fix-ppoll.diff b./toolchain/uClibc/patches-0.9.29/300-fix-ppoll.diff
new file mode 100644
index 0000000..125eb14
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/300-fix-ppoll.diff
@@ -0,0 +1,39 @@
+
+It will match kernel's sigset_t starting from 0.9.31.
+
+Please try attached patch.
+-- 
+vda
+
+diff -d -urpN uClibc.0/libc/sysdeps/linux/common/ppoll.c uClibc.1/libc/sysdeps/linux/common/ppoll.c
+--- uClibc.0/libc/sysdeps/linux/common/ppoll.c
++++ uClibc.1/libc/sysdeps/linux/common/ppoll.c
+@@ -17,6 +17,7 @@
+    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA.  */
+ 
++#include <signal.h>
+ #include <sys/syscall.h>
+ #include <sys/poll.h>
+ 
+@@ -26,9 +27,9 @@
+ 
+ # define __NR___libc_ppoll __NR_ppoll
+ static inline
+-_syscall4(int, __libc_ppoll, struct pollfd *, fds,
++_syscall5(int, __libc_ppoll, struct pollfd *, fds,
+ 	nfds_t, nfds, const struct timespec *, timeout,
+-	const __sigset_t *, sigmask);
++	const __sigset_t *, sigmask, size_t, sigsetsize)
+ 
+ int
+ ppoll (struct pollfd *fds, nfds_t nfds, const struct timespec *timeout,
+@@ -43,7 +44,7 @@
+       timeout = &tval;
+     }
+ 
+-  return __libc_ppoll(fds, nfds, timeout, sigmask);
++  return __libc_ppoll(fds, nfds, timeout, sigmask, _NSIG / 8);
+ }
+ libc_hidden_def(ppoll)
+ 
diff --git a./toolchain/uClibc/patches-0.9.29/910-gcc_4_3_include_fixed.patch b./toolchain/uClibc/patches-0.9.29/910-gcc_4_3_include_fixed.patch
new file mode 100644
index 0000000..fd80c21
--- /dev/null
+++ b./toolchain/uClibc/patches-0.9.29/910-gcc_4_3_include_fixed.patch
@@ -0,0 +1,12 @@
+--- a/Rules.mak
++++ b/Rules.mak
+@@ -498,7 +498,8 @@ CFLAGS += -I$(KERNEL_HEADERS)
+ 
+ # Sigh, some stupid versions of gcc can't seem to cope with '-iwithprefix include'
+ #CFLAGS+=-iwithprefix include
+-CFLAGS+=-isystem $(shell $(CC) -print-file-name=include)
++CC_IPREFIX:=$(shell $(CC) -print-file-name=include)
++CFLAGS+=-isystem $(CC_IPREFIX) -isystem $(CC_IPREFIX)-fixed
+ 
+ ifneq ($(DOASSERTS),y)
+ CFLAGS+=-DNDEBUG
diff --git a./tools/automake/patches/automake_1.11.1.patch b./tools/automake/patches/automake_1.11.1.patch
new file mode 100644
index 0000000..8ee38cd
--- /dev/null
+++ b./tools/automake/patches/automake_1.11.1.patch
@@ -0,0 +1,11 @@
+--- ./automake.in	2022-07-03 11:03:19.096141056 +0200
++++ ./automake_patched.in	2022-07-03 11:03:33.728284138 +0200
+@@ -4110,7 +4110,7 @@
+ sub substitute_ac_subst_variables ($)
+ {
+   my ($text) = @_;
+-  $text =~ s/\${([^ \t=:+{}]+)}/&substitute_ac_subst_variables_worker ($1)/ge;
++  $text =~ s/\$\{([^ \\t=:+\\{\\}]+)\}/substitute_ac_subst_variables_worker ($1)/ge;
+   return $text;
+ }
+ 
